/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: FocusPushPressZoom
  First Order Ambisonic (FOA) focus, press, push and zoom transformer
---------------------------------------------------------------------
*/


/* --- DEBUG STUFF ---

This plugin contains some code that ight be useful for debugging,
providing an alternative GUI displaying the content of various matrixes.
For regular use of the plugin the debug code is commented out in the same way as here.

--- DEBUG STUFF --- */


desc: First Order Ambisonic focus, press, push and zoom transformer

// Graphics file
filename:0,HorizontalBackground.png

// Import library with shared functions for matrix and graphics processing
import atkFunctionLibrary.jsfx-inc

in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

slider1:0<0,3,1{Focus, Press, Push, Zoom}>Transformation mode
slider2:0<-180,180,1>Azimuth (mouse)
slider3:0<-90,90,1>Elevation
slider4:0<0,1,0.01>Degree of transformation (mouse)

/* --- DEBUG STUFF ---*/
// Debug sliders:
slider5:0<0,1,1{GUI, Debug}>Display mode
slider6:0<0,13,1{matrixRotate1, matrixTumble1, matrixTransform, matrixTumble2, matrixRotate2, matrixDSP, matrixNewDSP, matrixInc, matrixDisplayPoints, matrixDisplayTransformed, matrixDisplayInterpreted, matrixCounter, matrixTest, matrixUnity}>Matrix to display
/*--- DEBUG STUFF --- */



/**********************************************************
Initialisation
**********************************************************/
@init

// Flag indicating that the plugin has not been fully initialised yet
initialised = 0;

azimuth   = 0;
elevation = 0.;

// Constants
rad2deg = 180. / $pi;
deg2rad = $pi / 180.;
sqrt2   = sqrt(2.);
rsqrt2  = 1. / sqrt2;

// Setting memory locations for a number of 4x4 matrixes as 1D arrays
matrixRotate1   = 1000;
matrixTumble1   = 1020;
matrixTransform = 1040;
matrixTumble2   = 1060;
matrixRotate2   = 1080;

// These are used for matrix multiplications
matrixTemp1     = 1100;
matrixTemp2     = 1120;

// Resulting matrixes used for DSP processing
matrixDSP       = 1200;
matrixNewDSP    = 1220;
matrixInc       = 1240;

// 4x8 matrixes for graphic display of transformations
matrixDisplayPoints      = 1300;
matrixDisplayTransformed = 1400;
matrixDisplayInterpreted = 5500;

// For testing
matrixCounter = 2000;
matrixTest    = 2100;
matrixUnity   = 2200;

// Generate test matrixes
i = 0;
loop(
  32,
  matrixCounter[i] = i * 0.01;
  i += 1;
);

i = 0;
loop(
  16,
  matrixUnity[i] = 0.;
  i += 1;
);

matrixUnity[0] = 1.;
matrixUnity[5] = 1.;
matrixUnity[10] = 1;
matrixUnity[15] = 1.;

matrixMultiplication  (matrixTest,    4, 4, matrixUnity,     4, 8, matrixCounter);



// This only needs to be generated once:
generateDisplaySignalMatrix(matrixDisplayPoints); 

function calculateMatrix()
(
  // Required for graphics
  cosAzimuth   = cos(azimuth);
  sinAzimuth   = sin(azimuth);

  cosElevation = cos(elevation);
  sinElevation = sin(elevation);
  
  // Generate matrixes
  generateRotationMatrix(matrixRotate1, (-azimuth));
  generateTumblelMatrix(matrixTumble1, -elevation);
  
  // Determine what transform to do
  mode == 0 ? (
    generateFocusMatrix(matrixTransform, transformAngle);
  ) : (
    mode == 1 ? (
      generatePressMatrix(matrixTransform, transformAngle)
    ) : (
      mode == 2? (
        generatePushMatrix(matrixTransform, transformAngle)
      ) : (
        generateZoomMatrix(matrixTransform, transformAngle)
      );
    );
  );
  generateRotationMatrix(matrixRotate2, azimuth);
  generateTumblelMatrix(matrixTumble2, elevation);
  
  /* Build processing matrix by performing a series of matrix multiplications
                        result =         left X                   right             */
  matrixMultiplication  (matrixTemp1,    4, 4, matrixTumble1,     4, 4, matrixRotate1);
  matrixMultiplication  (matrixTemp2,    4, 4, matrixTransform,   4, 4, matrixTemp1);
  matrixMultiplication  (matrixTemp1,    4, 4, matrixTumble2,     4, 4, matrixTemp2);
  matrixMultiplication  (matrixNewDSP,   4, 4, matrixRotate2,     4, 4, matrixTemp1);
  
  /* Transformation and interpretation of display points */
  matrixMultiplication  (matrixDisplayTransformed, 4, 4, matrixNewDSP, 4, 8, matrixDisplayPoints);
  interpreteProcessedPoints(matrixDisplayInterpreted, matrixDisplayTransformed);
  
  // Set initial DSP processing coefficients if the plugin has not yet been initialised
  initialised == 0 ?
  (
    i = 0;
    loop(16,
      matrixDSP[i] = matrixNewDSP[i];
    );
    // Now we are fully initialised
    initialised = 1;
  );
);


/**********************************************************
Updated slider value:
**********************************************************/
@slider

mode            = slider1;
azimuth         = slider2 * deg2rad;
elevation       = slider3 * deg2rad;
transformAngle  = slider4 * $pi * 0.5;

/* --- DEBUG STUFF ---*/
debugMode       = slider5;

slider6 == 0 ? (
  viewMatrix = matrixRotate1;
) : (
  slider6 == 1 ? (
    viewMatrix = matrixTumble1;
  ) : (
    slider6 == 2 ? (
      viewMatrix = matrixTransform;
    ) : (
      slider6 == 3 ? (
        viewMatrix = matrixTumble2;
      ) : (
        slider6 == 4 ? (
          viewMatrix = matrixRotate2;
        ) : (
          slider6 == 5 ? (
            viewMatrix = matrixDSP;
          ) : (
            slider6 == 6 ? (
              viewMatrix = matrixNewDSP;
            ) : (
              slider6 == 7 ? (
                viewMatrix = matrixInc;
              ) : (
                slider6 == 8 ? (
                  viewMatrix = matrixDisplayPoints;
                ) : (
                  slider6 == 9 ? (
                    viewMatrix = matrixDisplayTransformed;
                  ) : (
                    slider6 == 10 ? (
                      viewMatrix = matrixDisplayInterpreted;
                    ) : (
                      slider6 == 11 ? (
                        viewMatrix = matrixCounter;
                      ) : (
                        slider6 == 12 ? (
                          viewMatrix = matrixTest;
                        ) : (
                          viewMatrix = matrixUnity;
                        );
                      );
                    );
                  );
                );
              );
            );
          );
        );
      );
    );
  );
);



/*--- DEBUG STUFF --- */

calculateMatrix();


/**********************************************************
Graphics
**********************************************************/
@gfx 500 500

/* --- DEBUG STUFF ---*/
debugMode == 0 ?
(
/*--- DEBUG STUFF --- */

  // This is the regular interactive GUI mode:
  
  // Set colors
  gxColorSet(1, 1, 1, 1);
  determineGeometry();
  drawBackgroundImage();

  // Reset azimuth and transformAngle on mouse click
  mouse_cap == 1 ?
  (
    mouseX = mouse_x - centerX;
    mouseY = mouse_y - centerY;
    
    // Update azimuth and slider2 and notify GUI of the change
    azimuth = atan2(mouseX, -mouseY);
    slider2 = azimuth * rad2deg;
    slider_automate(slider2);
    
    // Update transformAngle and slider4 and notify GUI of the change
    slider4 = sqrt(mouseX*mouseX + mouseY*mouseY) * inverseRadius;
    // Restrict the range to [0, 1]
    slider4 > 1. ? slider4 = 1.;
    transformAngle = slider4 * $pi * 0.5;
    slider_automate(slider4);
    
    calculateMatrix();
  );
  
  // Draw eight points indicating the effect of the transform
  iii = 0;
  loop(
    8,
    gxColorSet(1., 0., 1., 1.);
    posX = centerX - radius * matrixDisplayInterpreted[8+iii];
    posY = centerY - radius * matrixDisplayInterpreted[iii];
    drawCenteredSquare(posX, posY, 10.);
    iii += 1;
  );

  // Draw red square as interactive direction indicator, size and color tint depends on elevation
  gxColorSet(1, 1.0 + 0.3 * sinElevation, 0.5 * sinElevation, 0.5 * sinElevation);
  posX = centerX + radius * slider4 * (sinAzimuth * cosElevation);
  posY = centerY - radius * slider4 * (cosAzimuth * cosElevation);
  squareSize = 4. * sinElevation + 12.;
  drawCenteredSquare(posX, posY, squareSize);
    
/* --- DEBUG STUFF ---  */
) : (
  
  // Debug mode can be used to inspect the content of the various matrixes
  gxColorSet(1., 1., 1., 1.);

  (slider6 > 7) && (slider6 < 13) ? numCols = 8. : numCols = 4.;
  
  // Iterate over columns:
  iii = 0;
  loop(numCols,
    // Iterate over rows
    jjj = 0;
    loop(4,
      gxPositionSet(iii*80 + 40, jjj*20 + 20);
      gfx_drawnumber( viewMatrix[iii + numCols*jjj],5);
      jjj = jjj + 1;
    );
    iii = iii + 1;
  );
);
/*--- DEBUG STUFF --- */
    

/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

inverseSamplesblock = 1. / samplesblock;

// Counter is called "ii" rather than "i" in order to ensure that we do not use the same counter here as in other sections
ii = 0;
loop(16,
  matrixInc[ii] = (matrixNewDSP[ii] - matrixDSP[ii]) * inverseSamplesblock;
  ii += 1;
);


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

ii = 0;
loop(16,
  matrixDSP[ii] += matrixInc[ii];
  ii += 1;
);

wIn = spl0;
xIn = spl1;
yIn = spl2;
zIn = spl3;

// Matrix multiplication with input signal:
spl0 = wIn * matrixDSP[0] + xIn  * matrixDSP[1]  + yIn * matrixDSP[2]  + zIn * matrixDSP[3];
spl1 = wIn * matrixDSP[4] + xIn  * matrixDSP[5]  + yIn * matrixDSP[6]  + zIn * matrixDSP[7];
spl2 = wIn * matrixDSP[8] + xIn  * matrixDSP[9]  + yIn * matrixDSP[10] + zIn * matrixDSP[11];
spl3 = wIn * matrixDSP[12] + xIn * matrixDSP[13] + yIn * matrixDSP[14] + zIn * matrixDSP[15];
