/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: AtoB
  A to B format encoder for a variety of tetrahedral orientations and W channel weights.
---------------------------------------------------------------------
*/

desc: A to B format encoder for a variety of tetrahedral orientations and W channel weights.

in_pin:A
in_pin:B
in_pin:C
in_pin:D

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

slider1:0<0,7,1{Front Left Up [FLU FRD BLD BRU], Front Left Down [FLD FRU BLU BRD], Front Left-Right [FL FR BU BD], Front Up-Down [FU FD BL BR], Front & Back Down [F BD BLU BRU], Front & Back Up [F BU BLD BRD], Front Left-Right Up [FLU FRU FD B], Front Left-Right Down [FLD FRD FU B] }>Orientation

slider2:0<-0,3,0{Decorrelated (Planewaves), Canonical, Unscaled, Cardioid}>Weight


/**********************************************************
Initialisation
**********************************************************/
@init

// Some constants:
recSqrt2   = 1. / sqrt(2.);
sqrt3Div2   = sqrt(3.) / 2.;
sqrt3Div6   = sqrt(3.) / 6.;
sqrt6Div3   = sqrt(6.) / 3.;
recSqrt6   = 1. / sqrt(6.);

// Setting memory locations for 4x4 matrix as 1D arrays
matrixDSP       = 1000;


/**********************************************************
Updated slider value:
**********************************************************/
@slider

/* Invert the 4x4 matrix with coefficients matrixDSP[0]..matrixDSP[15]

  The function for inverting a 4x4 matrix is lifted of StackOverflow:
  http://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix

  The code there is itself lifted of the MESA implementation of the GLU library:
  http://www.mesa3d.org/
*/
function invertMatrix()
(
  inv00 =  matrixDSP[5]  * matrixDSP[10] * matrixDSP[15] -
           matrixDSP[5]  * matrixDSP[11] * matrixDSP[14] -
           matrixDSP[9]  * matrixDSP[6]  * matrixDSP[15] +
           matrixDSP[9]  * matrixDSP[7]  * matrixDSP[14] +
           matrixDSP[13] * matrixDSP[6]  * matrixDSP[11] -
           matrixDSP[13] * matrixDSP[7]  * matrixDSP[10];

  inv10 = -matrixDSP[4]  * matrixDSP[10]  * matrixDSP[15] +
           matrixDSP[4]  * matrixDSP[11]  * matrixDSP[14] +
           matrixDSP[8]  * matrixDSP[6]  * matrixDSP[15] -
           matrixDSP[8]  * matrixDSP[7]  * matrixDSP[14] -
           matrixDSP[12] * matrixDSP[6]  * matrixDSP[11] +
           matrixDSP[12] * matrixDSP[7]  * matrixDSP[10];

  inv20 =  matrixDSP[4]  * matrixDSP[9]  * matrixDSP[15] -
           matrixDSP[4]  * matrixDSP[11] * matrixDSP[13] -
           matrixDSP[8]  * matrixDSP[5]  * matrixDSP[15] +
           matrixDSP[8]  * matrixDSP[7]  * matrixDSP[13] +
           matrixDSP[12] * matrixDSP[5]  * matrixDSP[11] -
           matrixDSP[12] * matrixDSP[7]  * matrixDSP[9];

  inv30 = -matrixDSP[4]  * matrixDSP[9]  * matrixDSP[14] +
           matrixDSP[4]  * matrixDSP[10] * matrixDSP[13] +
           matrixDSP[8]  * matrixDSP[5]  * matrixDSP[14] -
           matrixDSP[8]  * matrixDSP[6]  * matrixDSP[13] -
           matrixDSP[12] * matrixDSP[5]  * matrixDSP[10] +
           matrixDSP[12] * matrixDSP[6]  * matrixDSP[9];

  inv01 = -matrixDSP[1]  * matrixDSP[10] * matrixDSP[15] +
           matrixDSP[1]  * matrixDSP[11] * matrixDSP[14] +
           matrixDSP[9]  * matrixDSP[2]  * matrixDSP[15] -
           matrixDSP[9]  * matrixDSP[3]  * matrixDSP[14] -
           matrixDSP[13] * matrixDSP[2]  * matrixDSP[11] +
           matrixDSP[13] * matrixDSP[3]  * matrixDSP[10];

  inv11 =  matrixDSP[0]  * matrixDSP[10] * matrixDSP[15] -
           matrixDSP[0]  * matrixDSP[11] * matrixDSP[14] -
           matrixDSP[8]  * matrixDSP[2]  * matrixDSP[15] +
           matrixDSP[8]  * matrixDSP[3]  * matrixDSP[14] +
           matrixDSP[12] * matrixDSP[2]  * matrixDSP[11] - 
           matrixDSP[12] * matrixDSP[3]  * matrixDSP[10];

  inv21 = -matrixDSP[0]  * matrixDSP[9]  * matrixDSP[15] +
           matrixDSP[0]  * matrixDSP[11] * matrixDSP[13] +
           matrixDSP[8]  * matrixDSP[1]  * matrixDSP[15] -
           matrixDSP[8]  * matrixDSP[3]  * matrixDSP[13] -
           matrixDSP[12] * matrixDSP[1]  * matrixDSP[11] +
           matrixDSP[12] * matrixDSP[3]  * matrixDSP[9];

  inv31 =  matrixDSP[0]  * matrixDSP[9]  * matrixDSP[14] -
           matrixDSP[0]  * matrixDSP[10] * matrixDSP[13] -
           matrixDSP[8]  * matrixDSP[1]  * matrixDSP[14] +
           matrixDSP[8]  * matrixDSP[2]  * matrixDSP[13] +
           matrixDSP[12] * matrixDSP[1]  * matrixDSP[10] -
           matrixDSP[12] * matrixDSP[2]  * matrixDSP[9];

  inv02 =  matrixDSP[1]  * matrixDSP[6]  * matrixDSP[15] -
           matrixDSP[1]  * matrixDSP[7]  * matrixDSP[14] -
           matrixDSP[5]  * matrixDSP[2]  * matrixDSP[15] +
           matrixDSP[5]  * matrixDSP[3]  * matrixDSP[14] +
           matrixDSP[13] * matrixDSP[2]  * matrixDSP[7] -
           matrixDSP[13] * matrixDSP[3]  * matrixDSP[6];

  inv12 = -matrixDSP[0]  * matrixDSP[6]  * matrixDSP[15] +
           matrixDSP[0]  * matrixDSP[7]  * matrixDSP[14] +
           matrixDSP[4]  * matrixDSP[2]  * matrixDSP[15] -
           matrixDSP[4]  * matrixDSP[3]  * matrixDSP[14] -
           matrixDSP[12] * matrixDSP[2]  * matrixDSP[7] +
           matrixDSP[12] * matrixDSP[3]  * matrixDSP[6];

  inv22 =  matrixDSP[0]  * matrixDSP[5]  * matrixDSP[15] -
           matrixDSP[0]  * matrixDSP[7]  * matrixDSP[13] -
           matrixDSP[4]  * matrixDSP[1]  * matrixDSP[15] +
           matrixDSP[4]  * matrixDSP[3]  * matrixDSP[13] +
           matrixDSP[12] * matrixDSP[1]  * matrixDSP[7] -
           matrixDSP[12] * matrixDSP[3]  * matrixDSP[5];

  inv32 = -matrixDSP[0]  * matrixDSP[5]  * matrixDSP[14] +
           matrixDSP[0]  * matrixDSP[6]  * matrixDSP[13] +
           matrixDSP[4]  * matrixDSP[1]  * matrixDSP[14] -
           matrixDSP[4]  * matrixDSP[2]  * matrixDSP[13] -
           matrixDSP[12] * matrixDSP[1]  * matrixDSP[6] +
           matrixDSP[12] * matrixDSP[2]  * matrixDSP[5];

  inv03 = -matrixDSP[1]  * matrixDSP[6]  * matrixDSP[11] +
           matrixDSP[1]  * matrixDSP[7]  * matrixDSP[10] +
           matrixDSP[5]  * matrixDSP[2]  * matrixDSP[11] -
           matrixDSP[5]  * matrixDSP[3]  * matrixDSP[10] -
           matrixDSP[9]  * matrixDSP[2]  * matrixDSP[7] +
           matrixDSP[9]  * matrixDSP[3]  * matrixDSP[6];

  inv13 =  matrixDSP[0]  * matrixDSP[6]  * matrixDSP[11] -
           matrixDSP[0]  * matrixDSP[7]  * matrixDSP[10] -
           matrixDSP[4]  * matrixDSP[2]  * matrixDSP[11] +
           matrixDSP[4]  * matrixDSP[3]  * matrixDSP[10] +
           matrixDSP[8]  * matrixDSP[2]  * matrixDSP[7] -
           matrixDSP[8]  * matrixDSP[3]  * matrixDSP[6];

  inv23 = -matrixDSP[0]  * matrixDSP[5]  * matrixDSP[11] +
           matrixDSP[0]  * matrixDSP[7]  * matrixDSP[9] +
           matrixDSP[4]  * matrixDSP[1]  * matrixDSP[11] -
           matrixDSP[4]  * matrixDSP[3]  * matrixDSP[9] -
           matrixDSP[8]  * matrixDSP[1]  * matrixDSP[7] +
           matrixDSP[8]  * matrixDSP[3]  * matrixDSP[5];

  inv33 =  matrixDSP[0]  * matrixDSP[5]  * matrixDSP[10] -
           matrixDSP[0]  * matrixDSP[6]  * matrixDSP[9] -
	         matrixDSP[4]  * matrixDSP[1]  * matrixDSP[10] +
           matrixDSP[4]  * matrixDSP[2]  * matrixDSP[9] +
           matrixDSP[8]  * matrixDSP[1]  * matrixDSP[6] -
           matrixDSP[8]  * matrixDSP[2]  * matrixDSP[5];
					
  determinant = matrixDSP[0] * inv00 +
	              matrixDSP[1] * inv10 +
				        matrixDSP[2] * inv20 +
				        matrixDSP[3] * inv30;

  /* Might be difficult to check this in Reaper/JS, but it might also be redundant?
	if (determinant == 0)
    return false;
	*/

  determinant = 1.0 / determinant;

  matrixDSP[0] = inv00 * determinant;
	matrixDSP[1] = inv01 * determinant;
	matrixDSP[2] = inv02 * determinant;
	matrixDSP[3] = inv03 * determinant;
	
	matrixDSP[4] = inv10 * determinant;
	matrixDSP[5] = inv11 * determinant;
	matrixDSP[6] = inv12 * determinant;
	matrixDSP[7] = inv13 * determinant;
	
	matrixDSP[8] = inv20 * determinant;
	matrixDSP[9] = inv21 * determinant;
	matrixDSP[10] = inv22 * determinant;
	matrixDSP[11] = inv23 * determinant;
	
	matrixDSP[12] = inv30 * determinant;
	matrixDSP[13] = inv31 * determinant;
	matrixDSP[14] = inv32 * determinant;
	matrixDSP[15] = inv33 * determinant;
);


// Transformation matrix depends on direction
// This is the same code as for BtoA, but at the end we invert the matrix

// Option 0: orthogonal (front left up) [ FLU, FRD, BLD, BRU ]
slider1 == 0 ?
( 
  matrixDSP[0] =   0.5;
  matrixDSP[1] =   0.5;
  matrixDSP[2] =   0.5;
  matrixDSP[3] =   0.5;

  matrixDSP[4] =   0.5;
  matrixDSP[5] =   0.5;
  matrixDSP[6] =  -0.5;
  matrixDSP[7] =  -0.5;

  matrixDSP[8] =   0.5;
  matrixDSP[9] =  -0.5;
  matrixDSP[10] =  0.5;
  matrixDSP[11] = -0.5;

  matrixDSP[12] =  0.5;
  matrixDSP[13] = -0.5;
  matrixDSP[14] = -0.5;
  matrixDSP[15] =  0.5;
) :
(
  // Option 1: front left down [ FLD, FRU, BLU, BRD ]
  slider1 == 1 ?
  (
    matrixDSP[0] =  0.5;
    matrixDSP[1] =  0.5;
    matrixDSP[2] =  0.5;
    matrixDSP[3] = -0.5;

    matrixDSP[4] =  0.5;
    matrixDSP[5] =  0.5;
    matrixDSP[6] = -0.5;
    matrixDSP[7] =  0.5;

    matrixDSP[8] =  0.5;
    matrixDSP[9] = -0.5;
    matrixDSP[10] =  0.5;
    matrixDSP[11] =  0.5;

    matrixDSP[12] =  0.5;
    matrixDSP[13] = -0.5;
    matrixDSP[14] = -0.5;
    matrixDSP[15] = -0.5;
  ) :
  (
    // Option 2: front left-right [ FL, FR, BU, BD ]
    
    slider1 == 2 ?
    (     
      matrixDSP[0] =  0.5;
      matrixDSP[1] =  0.5;
      matrixDSP[2] =  recSqrt2;
      matrixDSP[3] =  0.;

      matrixDSP[4] =  0.5;
      matrixDSP[5] =  0.5;
      matrixDSP[6] = -recSqrt2;
      matrixDSP[7] =  0.;

      matrixDSP[8] =  0.5;
      matrixDSP[9] = -0.5;
      matrixDSP[10] =  0.;
      matrixDSP[11] =  recSqrt2;

      matrixDSP[12] =  0.5;
      matrixDSP[13] = -0.5;
      matrixDSP[14] =  0.;
      matrixDSP[15] = -recSqrt2;
    ) :
    (
      // Option 3: front up-down [ FU, FD, BL, BR ]
      
      slider1 == 3 ?
      (
        matrixDSP[0] =  0.5;
        matrixDSP[1] =  0.5;
        matrixDSP[2] =  0.;
        matrixDSP[3] =  recSqrt2;

        matrixDSP[4] =  0.5;
        matrixDSP[5] =  0.5;
        matrixDSP[6] =  0.;
        matrixDSP[7] = -recSqrt2;

        matrixDSP[8] =  0.5;
        matrixDSP[9] = -0.5;
        matrixDSP[10] =  recSqrt2;
        matrixDSP[11] =  0.;

        matrixDSP[12] =  0.5;
        matrixDSP[13] = -0.5;
        matrixDSP[14] = -recSqrt2;
        matrixDSP[15] =  0.;
      ) :
      (
        // Option 4: front & back down [ F, BD, BLU, BRU ]
        
        slider1 == 4 ?
        (
          matrixDSP[0] =  0.5;
          matrixDSP[1] =  sqrt3Div2;
          matrixDSP[2] =  0.;
          matrixDSP[3] =  0.;

          matrixDSP[4] =  0.5;
          matrixDSP[5] = -sqrt3Div6;
          matrixDSP[6] =  0.;
          matrixDSP[7] = -sqrt6Div3;

          matrixDSP[8] =  0.5;
          matrixDSP[9] = -sqrt3Div6;
          matrixDSP[10] =  recSqrt2;
          matrixDSP[11] =  recSqrt6;

          matrixDSP[12] =  0.5;
          matrixDSP[13] = -sqrt3Div6;
          matrixDSP[14] = -recSqrt2;
          matrixDSP[15] =  recSqrt6;
        ) :
        (
          // Option 5: front & back up [ F, BU, BLD, BRD ]
          
          slider1 == 5 ?
          (
            matrixDSP[0] =  0.5;
            matrixDSP[1] =  sqrt3Div2;
            matrixDSP[2] =  0.;
            matrixDSP[3] =  0.;

            matrixDSP[4] =  0.5;
            matrixDSP[5] = -sqrt3Div6;
            matrixDSP[6] =  0.0;
            matrixDSP[7] =  sqrt6Div3;

            matrixDSP[8] =  0.5;
            matrixDSP[9] = -sqrt3Div6;
            matrixDSP[10] =  recSqrt2;
            matrixDSP[11] = -recSqrt6;

            matrixDSP[12] =  0.5;
            matrixDSP[13] = -sqrt3Div6;
            matrixDSP[14] = -recSqrt2;
            matrixDSP[15] = -recSqrt6;
          ) :
          (
            // Option 6: front left-right up [ FLU, FRU, FD, B ]
            
            slider1 == 6 ?
            (
              matrixDSP[0] =  0.5;
              matrixDSP[1] =  sqrt3Div6;
              matrixDSP[2] =  recSqrt2;
              matrixDSP[3] =  recSqrt6;

              matrixDSP[4] =  0.5;
              matrixDSP[5] =  sqrt3Div6;
              matrixDSP[6] = -recSqrt2;
              matrixDSP[7] =  recSqrt6;

              matrixDSP[8] =  0.5;
              matrixDSP[9] =  sqrt3Div6;
              matrixDSP[10] =  0.;
              matrixDSP[11] = -sqrt6Div3;

              matrixDSP[12] =  0.5;
              matrixDSP[13] = -sqrt3Div2;
              matrixDSP[14] =  0.;
              matrixDSP[15] =  0.;
            ) :
            (
              // Option 7: front left-right down [ FLD, FRD, FU, B ]

              matrixDSP[0] =  0.5;
              matrixDSP[1] =  sqrt3Div6;
              matrixDSP[2] =  recSqrt2;
              matrixDSP[3] = -recSqrt6;

              matrixDSP[4] =  0.5;
              matrixDSP[5] =  sqrt3Div6;
              matrixDSP[6] = -recSqrt2;
              matrixDSP[7] = -recSqrt6;

              matrixDSP[8] =  0.5;
              matrixDSP[9] =  sqrt3Div6;
              matrixDSP[10] =  0.;
              matrixDSP[11] =  sqrt6Div3;

              matrixDSP[12] =  0.5;
              matrixDSP[13] = -sqrt3Div2;
              matrixDSP[14] =  0.;
              matrixDSP[15] =  0.;
            );

          );

        );

      );

    );
  );
);


// Weight:
// Option 0: Decorrelated (on the sphere)
slider2 == 0 ?
(
  g0 = sqrt(2./3.);
) :
(
  // Option 1: Canonical
  slider2 == 1 ?
  (
    g0 = 1.;
  ) :
  (
    // Option 2: Unscaled, W_gain = 1
    slider2 == 2 ?
    (
      g0 = sqrt(2.);
    ) :
    // Option 3: Cardioid
    (
      g0 = sqrt(6.);
    );
  );
);


// Compensate matrix for weight:
matrixDSP[0] =  g0 * matrixDSP[0];
matrixDSP[4] =  g0 * matrixDSP[4];
matrixDSP[8] =  g0 * matrixDSP[8];
matrixDSP[12] = g0 * matrixDSP[12];

// As compared to BtoA we now invert the matrix
invertMatrix();



/**********************************************************
Calculate audio sample
**********************************************************/
@sample
wIn = spl0;
xIn = spl1;
yIn = spl2;
zIn = spl3;

// Matrix multiplication with input signal:
spl0 = wIn * matrixDSP[0]  + xIn * matrixDSP[1]  + yIn * matrixDSP[2]  + zIn * matrixDSP[3];
spl1 = wIn * matrixDSP[4]  + xIn * matrixDSP[5]  + yIn * matrixDSP[6]  + zIn * matrixDSP[7];
spl2 = wIn * matrixDSP[8]  + xIn * matrixDSP[9]  + yIn * matrixDSP[10] + zIn * matrixDSP[11];
spl3 = wIn * matrixDSP[12] + xIn * matrixDSP[13] + yIn * matrixDSP[14] + zIn * matrixDSP[15];
