/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: atk-function-library.jsfx-inc
  Library of shared functions
---------------------------------------------------------------------



---------------------------------------------------------------------
Third Party Notices
---------------------------------------------------------------------


---------------------------------------------------------------------
The function for inverting a 4x4 matrix is lifted of StackOverflow:
http://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix

The code there is itself lifted of the MESA implementation of the GLU library:
http://www.mesa3d.org/
---------------------------------------------------------------------



---------------------------------------------------------------------
Support for Gerzon's Diametric Decoder Theorem (DDT) decoding algorithm is derived
from Aaron Heller's Octave code available at: http://www.ai.sri.com/ajh/ambisonics/

Benjamin, et al., "Localization in Horizontal-Only Ambisonic Systems"
Preprint from AES-121, 10/2006, San Francisco

Implementation in the SuperCollider3 version of the ATK is by
Joseph Anderson <j.anderson[at]ambisonictoolkit.net>
---------------------------------------------------------------------

---------------------------------------------------------------------
Irregular array decoding coefficients (5.0, 7.0) are kindly provided by
Bruce Wiggins: http://www.brucewiggins.co.uk/

B. Wiggins, "An Investigation into the Real-time Manipulation and Control of
Three-dimensional Sound Fields," PhD Thesis, University of Derby, Derby, 2004.
---------------------------------------------------------------------

*/



/********************************************************************
Functions in the init section can be used by any plugin loading this
file, encouraging DRY (don't repeat yourself)
********************************************************************/
@init



/*---------------------------------------------------------------------
  Mathematical functions
---------------------------------------------------------------------*/


/********************************************************************
Global constants
********************************************************************/

kInvPi   = 1. / $pi;

kRad2Deg = 180. / $pi;
kDeg2Rad = $pi / 180.;

kRad2Norm = 1. / $pi;

kSqrt2   = sqrt(2.);
kInvSqrt2  = 1. / kSqrt2;
kHalfInvSqrt2 = 0.5 * kInvSqrt2;



/********************************************************************
Maths: Round to nearest integer
********************************************************************/
function round(value)
(
  (value >= 0.) ? ceil(value + 0.5) : ceil(value - 0.5);
);


/********************************************************************
Maths: Convert linear gain to decibel
********************************************************************/
function db2amp(gain)
(
  pow(10.0, gain * 0.05);  // returns linear gain
);


/********************************************************************
Maths: Convert linear gain to decibel
********************************************************************/
function amp2db(gain)
(
  20 * log10(gain);       // returns dB gain
);


/********************************************************************
Maths: Clip value
********************************************************************/
function clipValue(value, min, max) local(temp, test)
(
  temp = value;
  
  temp < min ? (
    temp = min;
  ) : (
    temp > max ? (
      temp = max;
    );
  );
  temp      // return temp
);

/*---------------------------------------------------------------------
  Matrix section
---------------------------------------------------------------------*/


/********************************************************************
Matrix: Generate 4 x 8 matrix for equal 5.0 decoding. 
  Channel configuration: L - R - C - LFE - SL - SR - SBL - SBR
  LFE, SBL and SBR are not being used by this decoder
Decoding makes use of Wigging's matricies (credit at top)
********************************************************************/
function generateDecode50EqualMatrix(matrix)
(
  // Left
  matrix[0]  =  0.3650;
  matrix[1]  =  0.4350;
  matrix[2]  =  0.3400;
  matrix[3]  =  0.0;
  
  // Right
  matrix[4]  =  0.3650;
  matrix[5]  =  0.4350;
  matrix[6]  = -0.3400;
  matrix[7]  =  0.0;
  
  // Center
  matrix[8]  =  0.0000;
  matrix[9]  =  0.0850;
  matrix[10] =  0.0000;
  matrix[11] =  0.0;
  
  // LFE - no signal
  matrix[12] =  0.0;
  matrix[13] =  0.0;
  matrix[14] =  0.0;
  matrix[15] =  0.0;
  
  // Surround left (SL)
  matrix[16] =  0.5550;
  matrix[17] = -0.2850;
  matrix[18] =  0.4050;
  matrix[19] =  0.0;
  
  // Surround right (SR)
  matrix[20] =  0.5550;
  matrix[21] = -0.2850;
  matrix[22] = -0.4050;
  matrix[23] =  0.0;
  
  // Surround back left (SBL) - no signal
  matrix[24] =  0.0;
  matrix[25] =  0.0;
  matrix[26] =  0.0;
  matrix[27] =  0.0;
  
  // Surround back right (SBR) - no signal
  matrix[28] =  0.0;
  matrix[29] =  0.0;
  matrix[30] =  0.0;
  matrix[31] =  0.0;
);


/********************************************************************
Matrix: Generate 4 x 8 matrix for focused 5.0 decoding. 
  Channel configuration: L - R - C - LFE - SL - SR - SBL - SBR
  LFE, Lsb and Rsb are not being used by this decoder
Decoding makes use of Wigging's matricies (credit at top)
********************************************************************/
function generateDecode50FocusedMatrix(matrix)
(
  // Left
  matrix[0]  =  0.4250;
  matrix[1]  =  0.3600;
  matrix[2]  =  0.4050;
  matrix[3]  =  0.0;
  
  // Right
  matrix[4]  =  0.4250;
  matrix[5]  =  0.3600;
  matrix[6]  = -0.4050;
  matrix[7]  =  0.0;
  
  // Center
  matrix[8]  =  0.2000;
  matrix[9]  =  0.1600;
  matrix[10] =  0.0000;
  matrix[11] =  0.0;
  
  // LFE - no signal
  matrix[12] =  0.0;
  matrix[13] =  0.0;
  matrix[14] =  0.0;
  matrix[15] =  0.0;
  
  // Surround left (SL)
  matrix[16] =  0.4700;
  matrix[17] = -0.3300;
  matrix[18] =  0.4150;
  matrix[19] =  0.0;
  
  // Surround right (SR)
  matrix[20] =  0.4700;
  matrix[21] = -0.3300;
  matrix[22] = -0.4150;
  matrix[23] =  0.0;
  
  // Surround back left (SBL) - no signal
  matrix[24] =  0.0;
  matrix[25] =  0.0;
  matrix[26] =  0.0;
  matrix[27] =  0.0;
  
  // Surround back right (SBR) - no signal
  matrix[28] =  0.0;
  matrix[29] =  0.0;
  matrix[30] =  0.0;
  matrix[31] =  0.0;
);


/********************************************************************
Matrix: Generate 4 x 8 matrix for four channel 5.0 decoding.
  Channel configuration: L - R - C - LFE - Ls - Rs - LsB - RsB
  C, LFE, SBL and SBR are not being used by this decoder
Decoding makes use of Wigging's matricies (credit at top)
********************************************************************/
function generateDecode50FourlMatrix(matrix)
(
  // Left
  matrix[0]  =  0.4250;
  matrix[1]  =  0.3850;
  matrix[2]  =  0.3300;
  matrix[3]  =  0.0;
  
  // Right
  matrix[4]  =  0.4250;
  matrix[5]  =  0.3850;
  matrix[6]  = -0.3300;
  matrix[7]  =  0.0;
  
  // Center
  matrix[8]  =  0.0000;
  matrix[9]  =  0.0000;
  matrix[10] =  0.0000;
  matrix[11] =  0.0;
  
  // LFE - no signal
  matrix[12] =  0.0;
  matrix[13] =  0.0;
  matrix[14] =  0.0;
  matrix[15] =  0.0;
  
  // Surround left (SL)
  matrix[16] =  0.6300;
  matrix[17] = -0.2750;
  matrix[18] =  0.2850;
  matrix[19] =  0.0;
  
  // Surround right (SR)
  matrix[20] =  0.6300;
  matrix[21] = -0.2750;
  matrix[22] = -0.2850;
  matrix[23] =  0.0;
  
  // Surround back left (SBL) - no signal
  matrix[24] =  0.0;
  matrix[25] =  0.0;
  matrix[26] =  0.0;
  matrix[27] =  0.0;
  
  // Surround back right (SBR) - no signal
  matrix[28] =  0.0;
  matrix[29] =  0.0;
  matrix[30] =  0.0;
  matrix[31] =  0.0;  
);


/********************************************************************
Matrix: Generate 2x4 matrix for stereo decoding
********************************************************************/
function generateDecodeStereoMatrix(matrix, angle, pattern) local(g0, g1, g2)
(
	// calculate g0, g1, g2 (scaled by pattern)
	g0	= (1.0 - pattern) * sqrt(2);
	g1	= pattern * cos(angle);
	g2	= pattern * sin(angle);

  // Left
  matrix[0]  =  g0;
  matrix[1]  =  g1;
  matrix[2]  =  g2;
  matrix[3]  =  0.0;
  
  // Right
  matrix[4]  =  g0;
  matrix[5]  =  g1;
  matrix[6]  = -g2;
  matrix[7]  =  0.0;
);


/********************************************************************
Matrix: Generate 8x4 matrix with equally distributed source signals for display purposes
********************************************************************/
function generateDisplaySignalMatrix(matrix, numPoints) local(i, angle, inc, local kInvSqrt2)
(
  kInvSqrt2   = 1. / kSqrt2;
  
  // Encoding equally distributed points in the horisontal plane
  i = 0;
  angle = 0.;
  inc = 2. * $pi / numPoints;
  loop(numPoints,
    matrix[i]                = kInvSqrt2;
    matrix[i + numPoints]    = cos(angle);
    matrix[i + 2*numPoints]  = sin(angle);
    matrix[i + 3*numPoints]  = 0.;
    
    angle += inc;
    i += 1;
  );
);


/********************************************************************
Matrix: Interprete processed points

In the resulting matrixOut:
- Row 1 is x position of transformed point
- Row 2 is y position of transformed point
- Row 3 is z position of transformed point
- Row 4 is gain value in dB for transformed point
********************************************************************/
function interpreteProcessedPoints(matrixOut, matrixIn, numPoints) local(i, g0square, g1square, w, x, y, z, azi, ele, omni, gain)
(
  i = 0;
  loop(numPoints,
    w = matrixIn[i];
    x = matrixIn[numPoints + i];
    y = matrixIn[numPoints*2 + i];
    z = matrixIn[numPoints*3 + i];
    
    azi  = atan2(y, x);
    ele  = atan2(z, sqrt(x*x + y*y));
    
    // Omni transform angle
    g0square        = w * w;
    g1square        = x*x + y*y + z*z;
    omni = asin((2.*g0square - g1square) / (2.*g0square + g1square));
    
    // Gain
    gain = w * sqrt(2. / (1. + sin(omni)));
    
    // Normalise omni to [0,1] range
    omni = 2 * omni / $pi;
    omni = 1. - omni;
    
    // From this we calculate relative xyz position of the transformed point
    matrixOut[i]               = omni * cos(azi) * cos(ele);
    matrixOut[numPoints + i]   = omni * sin(azi) * cos(ele);
    matrixOut[numPoints*2 + i] = omni * sin(ele);
    matrixOut[numPoints*3 + i] = amp2db(gain);
    
    i += 1;
  );
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for B to A decoding
********************************************************************/
function generateBtoAMatrix(matrix, orientation, weight) local(g0, recSqrt6, sqrt3Div2, sqrt3Div6, sqrt6Div3)
(
  sqrt3Div2   = sqrt(3.) / 2.;
  sqrt3Div6   = sqrt(3.) / 6.;
  sqrt6Div3   = sqrt(6.) / 3.;
  recSqrt6   = 1. / sqrt(6.);
  
  // Option 0: orthogonal (front left up) [ FLU, FRD, BLD, BRU ]
  orientation == 0 ?
  ( 
    matrix[0] =   0.5;
    matrix[1] =   0.5;
    matrix[2] =   0.5;
    matrix[3] =   0.5;

    matrix[4] =   0.5;
    matrix[5] =   0.5;
    matrix[6] =  -0.5;
    matrix[7] =  -0.5;

    matrix[8] =   0.5;
    matrix[9] =  -0.5;
    matrix[10] =  0.5;
    matrix[11] = -0.5;

    matrix[12] =  0.5;
    matrix[13] = -0.5;
    matrix[14] = -0.5;
    matrix[15] =  0.5;
  ) :
  (
    // Option 1: front left down [ FLD, FRU, BLU, BRD ]
    orientation == 1 ?
    (
      matrix[0] =  0.5;
      matrix[1] =  0.5;
      matrix[2] =  0.5;
      matrix[3] = -0.5;

      matrix[4] =  0.5;
      matrix[5] =  0.5;
      matrix[6] = -0.5;
      matrix[7] =  0.5;

      matrix[8] =  0.5;
      matrix[9] = -0.5;
      matrix[10] =  0.5;
      matrix[11] =  0.5;

      matrix[12] =  0.5;
      matrix[13] = -0.5;
      matrix[14] = -0.5;
      matrix[15] = -0.5;
    ) :
    (
      // Option 2: front left-right [ FL, FR, BU, BD ]
    
      orientation == 2 ?
      (     
        matrix[0] =  0.5;
        matrix[1] =  0.5;
        matrix[2] =  kInvSqrt2;
        matrix[3] =  0.;

        matrix[4] =  0.5;
        matrix[5] =  0.5;
        matrix[6] = -kInvSqrt2;
        matrix[7] =  0.;

        matrix[8] =  0.5;
        matrix[9] = -0.5;
        matrix[10] =  0.;
        matrix[11] =  kInvSqrt2;

        matrix[12] =  0.5;
        matrix[13] = -0.5;
        matrix[14] =  0.;
        matrix[15] = -kInvSqrt2;
      ) :
      (
        // Option 3: front up-down [ FU, FD, BL, BR ]
      
        orientation == 3 ?
        (
          matrix[0] =  0.5;
          matrix[1] =  0.5;
          matrix[2] =  0.;
          matrix[3] =  kInvSqrt2;

          matrix[4] =  0.5;
          matrix[5] =  0.5;
          matrix[6] =  0.;
          matrix[7] = -kInvSqrt2;

          matrix[8] =  0.5;
          matrix[9] = -0.5;
          matrix[10] =  kInvSqrt2;
          matrix[11] =  0.;

          matrix[12] =  0.5;
          matrix[13] = -0.5;
          matrix[14] = -kInvSqrt2;
          matrix[15] =  0.;
        ) :
        (
          // Option 4: front & back down [ F, BD, BLU, BRU ]
        
          orientation == 4 ?
          (
            matrix[0] =  0.5;
            matrix[1] =  sqrt3Div2;
            matrix[2] =  0.;
            matrix[3] =  0.;

            matrix[4] =  0.5;
            matrix[5] = -sqrt3Div6;
            matrix[6] =  0.;
            matrix[7] = -sqrt6Div3;

            matrix[8] =  0.5;
            matrix[9] = -sqrt3Div6;
            matrix[10] =  kInvSqrt2;
            matrix[11] =  recSqrt6;

            matrix[12] =  0.5;
            matrix[13] = -sqrt3Div6;
            matrix[14] = -kInvSqrt2;
            matrix[15] =  recSqrt6;
          ) :
          (
            // Option 5: front & back up [ F, BU, BLD, BRD ]
          
            orientation == 5 ?
            (
              matrix[0] =  0.5;
              matrix[1] =  sqrt3Div2;
              matrix[2] =  0.;
              matrix[3] =  0.;

              matrix[4] =  0.5;
              matrix[5] = -sqrt3Div6;
              matrix[6] =  0.0;
              matrix[7] =  sqrt6Div3;

              matrix[8] =  0.5;
              matrix[9] = -sqrt3Div6;
              matrix[10] =  kInvSqrt2;
              matrix[11] = -recSqrt6;

              matrix[12] =  0.5;
              matrix[13] = -sqrt3Div6;
              matrix[14] = -kInvSqrt2;
              matrix[15] = -recSqrt6;
            ) :
            (
              // Option 6: front left-right up [ FLU, FRU, FD, B ]
            
              orientation == 6 ?
              (
                matrix[0] =  0.5;
                matrix[1] =  sqrt3Div6;
                matrix[2] =  kInvSqrt2;
                matrix[3] =  recSqrt6;

                matrix[4] =  0.5;
                matrix[5] =  sqrt3Div6;
                matrix[6] = -kInvSqrt2;
                matrix[7] =  recSqrt6;

                matrix[8] =  0.5;
                matrix[9] =  sqrt3Div6;
                matrix[10] =  0.;
                matrix[11] = -sqrt6Div3;

                matrix[12] =  0.5;
                matrix[13] = -sqrt3Div2;
                matrix[14] =  0.;
                matrix[15] =  0.;
              ) :
              (
                // Option 7: front left-right down [ FLD, FRD, FU, B ]

                matrix[0] =  0.5;
                matrix[1] =  sqrt3Div6;
                matrix[2] =  kInvSqrt2;
                matrix[3] = -recSqrt6;

                matrix[4] =  0.5;
                matrix[5] =  sqrt3Div6;
                matrix[6] = -kInvSqrt2;
                matrix[7] = -recSqrt6;

                matrix[8] =  0.5;
                matrix[9] =  sqrt3Div6;
                matrix[10] =  0.;
                matrix[11] =  sqrt6Div3;

                matrix[12] =  0.5;
                matrix[13] = -sqrt3Div2;
                matrix[14] =  0.;
                matrix[15] =  0.;
              );
            );
          );
        );
      );
    );
  );


  // Weight:
  // Option 0: Decorrelated (on the sphere)
  weight == 0 ?
  (
    g0 = sqrt(2./3.);
  ) :
  (
    // Option 1: Canonical
    weight == 1 ?
    (
      g0 = 1.;
    ) :
    (
      // Option 2: Unscaled, W_gain = 1
      weight == 2 ?
      (
        g0 = kSqrt2;
      ) :
      // Option 3: Cardioid
      (
        g0 = sqrt(6.);
      );
    );
  );

  // Compensate matrix for weight:
  matrix[0] =  g0 * matrix[0];
  matrix[4] =  g0 * matrix[4];
  matrix[8] =  g0 * matrix[8];
  matrix[12] = g0 * matrix[12];
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for directX transformation
********************************************************************/
function generateDirectMatrix(matrix, angle) local(g0, g1)
(
	g0 = sqrt(1 + sin(angle));
	g1 = sqrt(1 - sin(angle));
  
  matrix[0]  = g0;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g0;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g0;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for directX transformation
********************************************************************/
function generateDirectOrigoMatrix(matrix, angle) local(g0, g1)
(
  
  g0 = sqrt(1 + sin(angle));
  g1 = sqrt(1 - sin(angle));
  
  matrix[0]  = g0;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g1;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g1;
);

/********************************************************************
Matrix: Generate 1st order 4x4 matrix for dominateX transformation
********************************************************************/
function generateDominateMatrix(matrix, gain) local(k, g0, g1)
(
	k = db2amp(gain);		
	g0 = (k + 1. / k) * 0.5;
	g1 = (k - 1. / k) / kSqrt2;
    
  matrix[0]  = g0;
  matrix[1]  = g1 * 0.5;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g1;
  matrix[5]  = g0;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = 1.;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for focus transformation
********************************************************************/
function generateFocusMatrix(matrix, angle) local(g0, g1, g2)
(  
	g0 = 1. / (1 + sin(abs(angle)));
	g1 = kSqrt2 *  sin(angle) * g0;
	g2 = cos(angle) * g0;
  
  matrix[0]  = g0;
  matrix[1]  = g1 * 0.5;
  matrix[2]  = 0.;
  matrix[3]  = 0.;

  matrix[4]  = g1; 
  matrix[5]  = g0;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g2;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g2;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for mirrorX transformation
********************************************************************/
function generateMirrorMatrix(matrix)
(  
  matrix[0]  =  1.;
  matrix[1]  =  0.;
  matrix[2]  =  0.;
  matrix[3]  =  0.;

  matrix[4]  =  0.; 
  matrix[5]  = -1.;
  matrix[6]  =  0.;
  matrix[7]  =  0.;
  
  matrix[8]  =  0.;
  matrix[9]  =  0.;
  matrix[10] =  1.;
  matrix[11] =  0.;
  
  matrix[12] =  0.;
  matrix[13] =  0.;
  matrix[14] =  0.;
  matrix[15] =  1.;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for mirrorO transformation
********************************************************************/
function generateMirrorOMatrix(matrix)
(  
  matrix[0]  =  1.;
  matrix[1]  =  0.;
  matrix[2]  =  0.;
  matrix[3]  =  0.;

  matrix[4]  =  0.; 
  matrix[5]  = -1.;
  matrix[6]  =  0.;
  matrix[7]  =  0.;
  
  matrix[8]  =  0.;
  matrix[9]  =  0.;
  matrix[10] = -1.;
  matrix[11] =  0.;
  
  matrix[12] =  0.;
  matrix[13] =  0.;
  matrix[14] =  0.;
  matrix[15] = -1.;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for pressX transformation
********************************************************************/
function generatePressMatrix(matrix, angle) local(g0, g1, g2)
(
	g0 = kSqrt2 * sin(angle) * sin(abs(angle));
  g2 = cos(angle);
  g1 = g2 * g2;
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g0;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g2;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g2;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for pushX transformation
********************************************************************/
function generatePushMatrix(matrix, angle) local(g0, g1)
(  
  g0 = kSqrt2 * sin(angle) * sin(abs(angle));
  g1 = cos(angle);
  g1 = g1 * g1;
    
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g0;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g1;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g1;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for rotation transformation
********************************************************************/
function generateRotationMatrix(matrix, angle)
(
  // We use SpatDIF (navigational) coordinate system rather than mathematical.
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = cos(angle);
  matrix[6]  = sin(angle);
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = -matrix[6];
  matrix[10] =  matrix[5];
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);



/********************************************************************
Matrix: Generate 1st order 4x4 matrix for tilt transformation
********************************************************************/
function generateTiltlMatrix(matrix, angle)
(  
  matrix[0]  =  1.;
  matrix[1]  =  0.;
  matrix[2]  =  0.;
  matrix[3]  =  0.;
  
  matrix[4]  =  0.;
  matrix[5]  =  1.;
  matrix[6]  =  0.;
  matrix[7]  =  0.;
  
  matrix[8]  =  0.;
  matrix[9]  =  0.;
  matrix[10] =  cos(angle);
  matrix[11] = -sin(angle);
  
  matrix[12] =  0.;
  matrix[13] =  0.;
  matrix[14] = -matrix[11];
  matrix[15] =  matrix[10];  
);




/********************************************************************
Matrix: Generate 1st order 4x4 matrix for tumble transformation
********************************************************************/
function generateTumblelMatrix(matrix, angle)
(  
  matrix[0]  =  1.;
  matrix[1]  =  0.;
  matrix[2]  =  0.;
  matrix[3]  =  0.;
  
  matrix[4]  =  0.;
  matrix[5]  =  cos(angle);
  matrix[6]  =  0.;
  matrix[7]  = -sin(angle);
  
  matrix[8]  =  0.;
  matrix[9]  =  0.;
  matrix[10] =  1.;
  matrix[11] =  0.;
  
  matrix[12] =  0.;
  matrix[13] = -matrix[7];
  matrix[14] =  0.;
  matrix[15] =  matrix[5];  
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for zoomX transformation
********************************************************************/
function generateZoomMatrix(matrix, angle) local(g0, g1)
(
  g0 = sin(angle);
  g1 = cos(angle);
    
  matrix[0]  = 1.;
  matrix[1]  = g0 / kSqrt2;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g0 * kSqrt2;
  matrix[5]  = 1.;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g1;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g1;
);


/********************************************************************
Matrix: Multiplication of two matrixes: result = left x right
********************************************************************/
function matrixMultiplication(resultMatrix, numRowsLeft, numColsLeft, leftMatrix, numRowsRight, numColsRight, rightMatrix) local(row, col, i)
(
  // It is the responsibility of each plugin calling this function to ensure that numColsLeft == numRowsRight.
  // We do not check for that here.
  
  // Iterate over rows of left matrix
  row = 0;
  loop(numRowsLeft, 
    // Iterate over columns of right matrix
    col = 0;
    loop(numColsRight,
      // Calculate one cell
      resultMatrix[numColsRight*row + col] = 0.;
      i = 0;
      loop(numColsLeft,
        resultMatrix[numColsRight*row + col] += leftMatrix[numColsLeft*row + i] * rightMatrix[numColsRight*i + col];
        i += 1;
      );
      col += 1;
    );
    row += 1;
  );
);


/********************************************************************
Matrix: Invert a 4x4 matrix
********************************************************************/
function invertMatrix(matrix) local(determinant) local(inv)
(
  // Setting memory slot for local array
  inv = 10000;
  
  inv[0] =   matrix[5]  * matrix[10] * matrix[15] -
             matrix[5]  * matrix[11] * matrix[14] -
             matrix[9]  * matrix[6]  * matrix[15] +
             matrix[9]  * matrix[7]  * matrix[14] +
             matrix[13] * matrix[6]  * matrix[11] -
             matrix[13] * matrix[7]  * matrix[10];

  inv[4] =  -matrix[4]  * matrix[10]  * matrix[15] +
             matrix[4]  * matrix[11]  * matrix[14] +
             matrix[8]  * matrix[6]  * matrix[15] -
             matrix[8]  * matrix[7]  * matrix[14] -
             matrix[12] * matrix[6]  * matrix[11] +
             matrix[12] * matrix[7]  * matrix[10];

  inv[8] =   matrix[4]  * matrix[9]  * matrix[15] -
             matrix[4]  * matrix[11] * matrix[13] -
             matrix[8]  * matrix[5]  * matrix[15] +
             matrix[8]  * matrix[7]  * matrix[13] +
             matrix[12] * matrix[5]  * matrix[11] -
             matrix[12] * matrix[7]  * matrix[9];

  inv[12] = -matrix[4]  * matrix[9]  * matrix[14] +
             matrix[4]  * matrix[10] * matrix[13] +
             matrix[8]  * matrix[5]  * matrix[14] -
             matrix[8]  * matrix[6]  * matrix[13] -
             matrix[12] * matrix[5]  * matrix[10] +
             matrix[12] * matrix[6]  * matrix[9];

  inv[1] =  -matrix[1]  * matrix[10] * matrix[15] +
             matrix[1]  * matrix[11] * matrix[14] +
             matrix[9]  * matrix[2]  * matrix[15] -
             matrix[9]  * matrix[3]  * matrix[14] -
             matrix[13] * matrix[2]  * matrix[11] +
             matrix[13] * matrix[3]  * matrix[10];

  inv[5] =   matrix[0]  * matrix[10] * matrix[15] -
             matrix[0]  * matrix[11] * matrix[14] -
             matrix[8]  * matrix[2]  * matrix[15] +
             matrix[8]  * matrix[3]  * matrix[14] +
             matrix[12] * matrix[2]  * matrix[11] - 
             matrix[12] * matrix[3]  * matrix[10];

  inv[9] =  -matrix[0]  * matrix[9]  * matrix[15] +
             matrix[0]  * matrix[11] * matrix[13] +
             matrix[8]  * matrix[1]  * matrix[15] -
             matrix[8]  * matrix[3]  * matrix[13] -
             matrix[12] * matrix[1]  * matrix[11] +
             matrix[12] * matrix[3]  * matrix[9];

  inv[13] =  matrix[0]  * matrix[9]  * matrix[14] -
             matrix[0]  * matrix[10] * matrix[13] -
             matrix[8]  * matrix[1]  * matrix[14] +
             matrix[8]  * matrix[2]  * matrix[13] +
             matrix[12] * matrix[1]  * matrix[10] -
             matrix[12] * matrix[2]  * matrix[9];

  inv[2] =   matrix[1]  * matrix[6]  * matrix[15] -
             matrix[1]  * matrix[7]  * matrix[14] -
             matrix[5]  * matrix[2]  * matrix[15] +
             matrix[5]  * matrix[3]  * matrix[14] +
             matrix[13] * matrix[2]  * matrix[7] -
             matrix[13] * matrix[3]  * matrix[6];

  inv[6] =  -matrix[0]  * matrix[6]  * matrix[15] +
             matrix[0]  * matrix[7]  * matrix[14] +
             matrix[4]  * matrix[2]  * matrix[15] -
             matrix[4]  * matrix[3]  * matrix[14] -
             matrix[12] * matrix[2]  * matrix[7] +
             matrix[12] * matrix[3]  * matrix[6];

  inv[10] =  matrix[0]  * matrix[5]  * matrix[15] -
             matrix[0]  * matrix[7]  * matrix[13] -
             matrix[4]  * matrix[1]  * matrix[15] +
             matrix[4]  * matrix[3]  * matrix[13] +
             matrix[12] * matrix[1]  * matrix[7] -
             matrix[12] * matrix[3]  * matrix[5];

  inv[14] = -matrix[0]  * matrix[5]  * matrix[14] +
             matrix[0]  * matrix[6]  * matrix[13] +
             matrix[4]  * matrix[1]  * matrix[14] -
             matrix[4]  * matrix[2]  * matrix[13] -
             matrix[12] * matrix[1]  * matrix[6] +
             matrix[12] * matrix[2]  * matrix[5];

  inv[3] =  -matrix[1]  * matrix[6]  * matrix[11] +
             matrix[1]  * matrix[7]  * matrix[10] +
             matrix[5]  * matrix[2]  * matrix[11] -
             matrix[5]  * matrix[3]  * matrix[10] -
             matrix[9]  * matrix[2]  * matrix[7] +
             matrix[9]  * matrix[3]  * matrix[6];

  inv[7] =   matrix[0]  * matrix[6]  * matrix[11] -
             matrix[0]  * matrix[7]  * matrix[10] -
             matrix[4]  * matrix[2]  * matrix[11] +
             matrix[4]  * matrix[3]  * matrix[10] +
             matrix[8]  * matrix[2]  * matrix[7] -
             matrix[8]  * matrix[3]  * matrix[6];

  inv[11] = -matrix[0]  * matrix[5]  * matrix[11] +
             matrix[0]  * matrix[7]  * matrix[9] +
             matrix[4]  * matrix[1]  * matrix[11] -
             matrix[4]  * matrix[3]  * matrix[9] -
             matrix[8]  * matrix[1]  * matrix[7] +
             matrix[8]  * matrix[3]  * matrix[5];

  inv[15] =  matrix[0]  * matrix[5]  * matrix[10] -
             matrix[0]  * matrix[6]  * matrix[9] -
             matrix[4]  * matrix[1]  * matrix[10] +
             matrix[4]  * matrix[2]  * matrix[9] +
             matrix[8]  * matrix[1]  * matrix[6] -
             matrix[8]  * matrix[2]  * matrix[5];
					
  determinant = matrix[0] * inv[0] +
	              matrix[1] * inv[4] +
				        matrix[2] * inv[8] +
				        matrix[3] * inv[12];

  /* Might be difficult to check this in Reaper/JS, but it might also be redundant?
	if (determinant == 0)
    return false;
	*/

  determinant = 1.0 / determinant;

  matrix[0]  = inv[0]  * determinant;
	matrix[1]  = inv[1]  * determinant;
	matrix[2]  = inv[2]  * determinant;
	matrix[3]  = inv[3]  * determinant;
	
	matrix[4]  = inv[4]  * determinant;
	matrix[5]  = inv[5]  * determinant;
	matrix[6]  = inv[6]  * determinant;
	matrix[7]  = inv[7]  * determinant;
	
	matrix[8]  = inv[8]  * determinant;
	matrix[9]  = inv[9]  * determinant;
	matrix[10] = inv[10] * determinant;
	matrix[11] = inv[11] * determinant;
	
	matrix[12] = inv[12] * determinant;
	matrix[13] = inv[13] * determinant;
	matrix[14] = inv[14] * determinant;
	matrix[15] = inv[15] * determinant;
);





/*---------------------------------------------------------------------
  Graphics section
---------------------------------------------------------------------*/

/********************************************************************
Graphics: Set drawing color
********************************************************************/
function gxColorSet(alpha, red, green, blue)
(
	gfx_a = alpha;
	gfx_r = red;
	gfx_g = green;
	gfx_b = blue;
);


/********************************************************************
Graphics: Set drawing position
********************************************************************/
function gxPositionSet(x, y)
(
	gfx_x = x;
	gfx_y = y;
);


/********************************************************************
Graphics: Color convertion utility for hsl to rgb convertions
********************************************************************/
function hls_value(n1, n2, hue)
(
	// Restrict incoming range to [0., 360.]
  hue > 360.0 ? (
    hue -= 360.;
  ) : (
    hue < 0.0 ? (
      hue += 360.;
    );
  );
  
  hue < 60. ? (
    n1+(n2-n1)*hue/60.
  ) : (
    hue < 180. ? (
      n2;
    ) : (
      hue < 240. ? (
        n1+(n2-n1)*(240-hue)/60.;
      ) : (
        n1;
      );
    );
  );
);


/********************************************************************
Graphics: Express gain (in dB) as graphics color
********************************************************************/
function gainToColor(gain, gainLowLimit, gainHighLimit, verticalOffset) local(hue, saturation, lightness, m1, m2, red, green, blue)
(
  // Clip gain to prescribed range:
  gain < gainLowLimit ? (
    gain = gainLowLimit;
  ) : (
    gain > gainHighLimit ? (
      gain = gainHighLimit;
    );
  );
  
  hue = ((gain - gainHighLimit) / (gainLowLimit - gainHighLimit)) * 240.;
  
  // Saturation and lightness depends on vertical position
  verticalOffset < 0 ? (
    saturation = 1. - 0.3*verticalOffset;
    lightness = 0.5;
  ) : (
    saturation = 1.;
    lightness = 0.5 + 0.3*verticalOffset;
  );
  
  lightness <= 0.5 ? (
    m2 = lightness*(1.0+saturation);
  ) : (
    m2 = lightness+saturation-lightness*saturation;
  );
  
  m1 = 2.0 * lightness-m2;
  
  saturation == 0.0 ? (
    red = lightness;
  	green = lightness;
  	blue = lightness;
  ) : (
    red = hls_value(m1, m2, hue+120.0);
  	green = hls_value(m1, m2, hue);
  	blue = hls_value(m1, m2, hue-120.0);
  );

  gxColorSet(1., red, green, blue)
);


/********************************************************************
Graphics: Determine geometry
********************************************************************/
function determineGeometry()
(
  centerX = gfx_w  * 0.5;
  centerY = gfx_h * 0.5;

  centerX < centerY ? radius = centerX : radius = centerY;
  radius = radius - 10;
  inverseRadius = 1. / radius;
);


/********************************************************************
Graphics: Draw background image based on ICST ambimonitor
********************************************************************/
function drawBackgroundImage(sourceWidth, sourceHeight, dstLeft, dstTop, dstWidth, dstHeight) local(coordinatelist)
(
  // Setting memory slot for local array
  coordinatelist = 10000;
  
  // Background graphics
  coordinatelist[0] = 0;                  //left-most pixel location for source
  coordinatelist[1] = 0;                  //top-most pixel location for source
  coordinatelist[2] = sourceWidth;        //width of source
  coordinatelist[3] = sourceHeight;       //height of source
  coordinatelist[4] = dstLeft;            //left-most pixel location of destination
  coordinatelist[5] = dstTop;             //top-most pixel location of destination
  coordinatelist[6] = dstWidth;           //width of destination to fill
  coordinatelist[7] = dstHeight;          //height of destination to fill
  coordinatelist[8] =0;                   //represents offset from center of image
  coordinatelist[9] =0;                   //represents offset from center of image
  gfx_blitext(0,coordinatelist,0);

);



/********************************************************************
Graphics: Draw line segment
********************************************************************/
function drawLineSegment(position1x, position1y, position2x, position2y, antiAliasing)
(
  gfx_x = position1x;
  gfx_y = position1y;
  gfx_lineto(position2x, position2y, antiAliasing);
);


/********************************************************************
Graphics: Draw outline of polygon with four sides and four corners
********************************************************************/
function drawQuadrangleOutline(position1x, position1y, position2x, position2y, position3x, position3y, position4x, position4y, antiAliasing)
(
  gfx_x = position1x;
  gfx_y = position1y;
  gfx_lineto(position2x, position2y, antiAliasing);
  gfx_lineto(position3x, position3y, antiAliasing);
  gfx_lineto(position4x, position4y, antiAliasing);
  gfx_lineto(position1x, position1y, antiAliasing);
);


/********************************************************************
Graphics: Draw outline of polygon with four sides and four corners
********************************************************************/
function drawRectangle(left, top, right, bottom)
(
  gfx_x = left;
  gfx_y = top;
  gfx_rectto(right, bottom);
);

/********************************************************************
Graphics: Draw centered filled-in square
********************************************************************/
function drawCenteredSquare(centerX, centerY, squareSize) local(halfSize)
(
  halfSize = squareSize * 0.5;
  gfx_x = centerX - halfSize;
  gfx_y = centerY - halfSize;
  gfx_rectto(centerX + halfSize, centerY + halfSize);
);



/********************************************************************
Graphics: Draw interactive square
********************************************************************/
function drawInteractionSquare(centerX, centerY, squareSize) local(halfSize, a, r, g, b)
(
  // Temporarily store incoming color
	a = gfx_a;
	r = gfx_r;
	g = gfx_g;
	b = gfx_b;
  
  // Draw square with white frame:
  drawCenteredSquare(centerX, centerY, squareSize);
  gxColorSet(1., 1., 1., 1.);
  halfSize = squareSize * 0.5;
  drawQuadrangleOutline(centerX-halfSize, centerY-halfSize, 
                        centerX+halfSize, centerY-halfSize,
                        centerX+halfSize, centerY+halfSize,
                        centerX-halfSize, centerY+halfSize,
                        1.
                      );
                      
  // Return color to its prior value
  gxColorSet(a, r, g, b);
);


/********************************************************************
Graphics: Draw points illustrating the effect of various transforms
********************************************************************/
function displayTransformedPoints(matrix, numPoints) local(i, posX, posY, posZ, squareSize)
(
  // Draw eight points indicating the effect of the transform
  // TODO: Also take z value into account in this visualisation?
  i = 0;
  loop(
    numPoints,
    posX = centerX - radius * matrix[numPoints+i];
    posY = centerY - radius * matrix[i];
    posZ = matrix[2*numPoints+i];
    
    // Size, saturation and luminocity depends on posZ
    squareSize = 2. * posZ + 8.;
    gainToColor(matrix[3*numPoints+i], -24., 6., posZ);
    
    drawCenteredSquare(posX, posY, squareSize);
    i += 1;
  );
);


/********************************************************************
Graphics: Draw multi-channel level meter
********************************************************************/
function drawMultichannelLevelMeterInterface(gain, displaydDbGain, numChannels)
local (decibel, deltaX, hideSectionWidth, i, left, 
  stripHeight, stripLeft, stripRight, stripSeparatorHeight, stripTotalHeight, stripWidth, 
  top, xPos, yPos2, stripTop, stripBottom)
(
  // Setting memory slots for local arrays:
  stripTop    = 10000;
  stripBottom = 10100;
  
  // Set colors
  gxColorSet(1, 1, 1, 1);

  // Draw background image providing gain color indication
  left             = 10;
  top              = 10;
  stripWidth       = gfx_w - 20;
  stripTotalHeight = gfx_h - 20;
  drawBackgroundImage(661, 1, left, top, stripWidth, stripTotalHeight);

  // Geometry for channel strips - if more than 4 channels they are grouped as pairs
  numChannels > 4 ? (
    stripHeight          = (stripTotalHeight-(numChannels*0.5)) / (numChannels+1);
    stripSeparatorHeight = (stripTotalHeight-(numChannels*0.5)) / ((numChannels+1) * (numChannels*0.5 - 1));
    stripLeft            = 10.;                               // Same for all strips
    stripRight           = gfx_w - 10.;                       // Same for all strips
  ) : (
    stripHeight          = (stripTotalHeight-(numChannels-1.)) / numChannels;
    stripSeparatorHeight = 1.;
    stripLeft            = 10.;                               // Same for all strips
    stripRight           = gfx_w - 10.;                       // Same for all strips
  );
  

  // Calculate borders for each section of the multichannel meter
  i = 0;
  top = 10;
  loop(numChannels,
    stripTop[i]    = top;
    stripBottom[i] = top + stripHeight;
    top += stripHeight + 1.;
    i += 1.;
  
    stripTop[i]    = top;
    stripBottom[i] = top + stripHeight;
    top += stripHeight + stripSeparatorHeight;
  
    i += 1.;
  );

  // Draw separators:
  gxColorSet(1., 0, 0, 0);
  i = 0;
  loop(numChannels-1,
    drawRectangle(stripLeft, stripBottom[i], stripRight, stripTop[i+1]);
    i += 1.;
  );

  // Draw black square in front of background to display gain
  i = 0;
  top = 10;
  loop(numChannels,  
    // Determine max absolute sample value in dB:
    decibel = amp2db(sqrt(gain[i]));
    decibel = clipValue(decibel, -60. , 6);
    decibel > displaydDbGain[i] ?
      displaydDbGain[i] = decibel;
  
    // Mask parts of background
    hideSectionWidth = (6. - displaydDbGain[i]) / 66.;
    drawRectangle(stripLeft + round((1. - hideSectionWidth) * stripWidth), stripTop[i]-1, stripRight, stripBottom[i]+1);
  
    // Reset gain:
    gain[i] = 0.;
    displaydDbGain[i] -= 2.;
  
    i += 1;
  );

  // Drawing vertical red line at 0 dB. This will be partly masked later
  xPos = 10. + 10*deltaX;
  yPos2 = gfx_h-10.;
  gxColorSet(1., 1., 0., 0.);
  drawLineSegment(xPos, 10., xPos, yPos2, 1.);

  // Draw vertical db lines for every 6 dB:
  gxColorSet(0.75, 1., 1., 1.);
  i = 0;
  xPos = 10.;
  yPos2 = gfx_h-10.;
  deltaX = stripWidth / 11.;
  loop(12,
    drawLineSegment(xPos, 10., xPos, yPos2, 1.);
    xPos += deltaX;
    i += 1;
  );

  // Write dB values. Don't need to do so at 0 db as it already stands out colorwise
  yPos2 = gfx_h-20.;

  gxPositionSet(13., yPos2);
  gfx_drawnumber(-60,0);

  gxPositionSet(13. + 2*deltaX, yPos2);
  gfx_drawnumber(-48,0);

  gxPositionSet(13. + 4*deltaX, yPos2);
  gfx_drawnumber(-36,0);

  gxPositionSet(13. + 6*deltaX, yPos2);
  gfx_drawnumber(-24,0);

  gxPositionSet(13. + 8*deltaX, yPos2);
  gfx_drawnumber(-12,0);
);


/********************************************************************
Graphics: Post matrix content to GUI, can be used for debugging
********************************************************************/
function postMatrixForDebugging(matrix, numRows, numCols) local(i, j, a, r, g, b)
(
  // Temporarily store gx color, and set color to white
	a = gfx_a;
	r = gfx_r;
	g = gfx_g;
	b = gfx_b;
  gxColorSet(1., 1., 1., 1.);
  
  // Iterate over columns:
  i = 0;
  loop(numCols,
    // Iterate over rows
    j = 0;
    loop(numRows,
      gxPositionSet(i*80 + 40, j*20 + 20);
      gfx_drawnumber( matrix[i + numCols*j],5);
      j += 1;
    );
    i += 1;
  );
  // Return color to what it used to be
  gxColorSet(a, r, g, b);
);