/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
The function for inverting a 4x4 matrix is lifted of StackOverflow:
http://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix

The code there is itself lifted of the MESA implementation of the GLU library:
http://www.mesa3d.org/
---------------------------------------------------------------------



---------------------------------------------------------------------
  Class: atk-function-library.jsfx-inc
  Library of shared functions
---------------------------------------------------------------------
*/



/********************************************************************
Functions in the init section can be used by any plugin loading this
file, encouraging DRY (don't repeat yourself)
********************************************************************/
@init


/*---------------------------------------------------------------------
  Mathematical functions
---------------------------------------------------------------------*/

/********************************************************************
Maths: Convert linear gain to decibel
********************************************************************/
function db2amp(gain)
(
  pow(10.0, gain * 0.05);  // returns linear gain
);


/********************************************************************
Maths: Convert linear gain to decibel
********************************************************************/
function amp2db(gain)
(
  20 * log10(gain);       // returns dB gain
);



/*---------------------------------------------------------------------
  Matrix section
---------------------------------------------------------------------*/

/********************************************************************
Matrix: Generate 1st order 4x4 matrix for rotation transformation
********************************************************************/
function generateBtoAMatrix(matrix, orientation, weight) local(g0)
(
  // Option 0: orthogonal (front left up) [ FLU, FRD, BLD, BRU ]
  orientation == 0 ?
  ( 
    matrixDSP[0] =   0.5;
    matrixDSP[1] =   0.5;
    matrixDSP[2] =   0.5;
    matrixDSP[3] =   0.5;

    matrixDSP[4] =   0.5;
    matrixDSP[5] =   0.5;
    matrixDSP[6] =  -0.5;
    matrixDSP[7] =  -0.5;

    matrixDSP[8] =   0.5;
    matrixDSP[9] =  -0.5;
    matrixDSP[10] =  0.5;
    matrixDSP[11] = -0.5;

    matrixDSP[12] =  0.5;
    matrixDSP[13] = -0.5;
    matrixDSP[14] = -0.5;
    matrixDSP[15] =  0.5;
  ) :
  (
    // Option 1: front left down [ FLD, FRU, BLU, BRD ]
    orientation == 1 ?
    (
      matrixDSP[0] =  0.5;
      matrixDSP[1] =  0.5;
      matrixDSP[2] =  0.5;
      matrixDSP[3] = -0.5;

      matrixDSP[4] =  0.5;
      matrixDSP[5] =  0.5;
      matrixDSP[6] = -0.5;
      matrixDSP[7] =  0.5;

      matrixDSP[8] =  0.5;
      matrixDSP[9] = -0.5;
      matrixDSP[10] =  0.5;
      matrixDSP[11] =  0.5;

      matrixDSP[12] =  0.5;
      matrixDSP[13] = -0.5;
      matrixDSP[14] = -0.5;
      matrixDSP[15] = -0.5;
    ) :
    (
      // Option 2: front left-right [ FL, FR, BU, BD ]
    
      orientation == 2 ?
      (     
        matrixDSP[0] =  0.5;
        matrixDSP[1] =  0.5;
        matrixDSP[2] =  recSqrt2;
        matrixDSP[3] =  0.;

        matrixDSP[4] =  0.5;
        matrixDSP[5] =  0.5;
        matrixDSP[6] = -recSqrt2;
        matrixDSP[7] =  0.;

        matrixDSP[8] =  0.5;
        matrixDSP[9] = -0.5;
        matrixDSP[10] =  0.;
        matrixDSP[11] =  recSqrt2;

        matrixDSP[12] =  0.5;
        matrixDSP[13] = -0.5;
        matrixDSP[14] =  0.;
        matrixDSP[15] = -recSqrt2;
      ) :
      (
        // Option 3: front up-down [ FU, FD, BL, BR ]
      
        orientation == 3 ?
        (
          matrixDSP[0] =  0.5;
          matrixDSP[1] =  0.5;
          matrixDSP[2] =  0.;
          matrixDSP[3] =  recSqrt2;

          matrixDSP[4] =  0.5;
          matrixDSP[5] =  0.5;
          matrixDSP[6] =  0.;
          matrixDSP[7] = -recSqrt2;

          matrixDSP[8] =  0.5;
          matrixDSP[9] = -0.5;
          matrixDSP[10] =  recSqrt2;
          matrixDSP[11] =  0.;

          matrixDSP[12] =  0.5;
          matrixDSP[13] = -0.5;
          matrixDSP[14] = -recSqrt2;
          matrixDSP[15] =  0.;
        ) :
        (
          // Option 4: front & back down [ F, BD, BLU, BRU ]
        
          orientation == 4 ?
          (
            matrixDSP[0] =  0.5;
            matrixDSP[1] =  sqrt3Div2;
            matrixDSP[2] =  0.;
            matrixDSP[3] =  0.;

            matrixDSP[4] =  0.5;
            matrixDSP[5] = -sqrt3Div6;
            matrixDSP[6] =  0.;
            matrixDSP[7] = -sqrt6Div3;

            matrixDSP[8] =  0.5;
            matrixDSP[9] = -sqrt3Div6;
            matrixDSP[10] =  recSqrt2;
            matrixDSP[11] =  recSqrt6;

            matrixDSP[12] =  0.5;
            matrixDSP[13] = -sqrt3Div6;
            matrixDSP[14] = -recSqrt2;
            matrixDSP[15] =  recSqrt6;
          ) :
          (
            // Option 5: front & back up [ F, BU, BLD, BRD ]
          
            orientation == 5 ?
            (
              matrixDSP[0] =  0.5;
              matrixDSP[1] =  sqrt3Div2;
              matrixDSP[2] =  0.;
              matrixDSP[3] =  0.;

              matrixDSP[4] =  0.5;
              matrixDSP[5] = -sqrt3Div6;
              matrixDSP[6] =  0.0;
              matrixDSP[7] =  sqrt6Div3;

              matrixDSP[8] =  0.5;
              matrixDSP[9] = -sqrt3Div6;
              matrixDSP[10] =  recSqrt2;
              matrixDSP[11] = -recSqrt6;

              matrixDSP[12] =  0.5;
              matrixDSP[13] = -sqrt3Div6;
              matrixDSP[14] = -recSqrt2;
              matrixDSP[15] = -recSqrt6;
            ) :
            (
              // Option 6: front left-right up [ FLU, FRU, FD, B ]
            
              orientation == 6 ?
              (
                matrixDSP[0] =  0.5;
                matrixDSP[1] =  sqrt3Div6;
                matrixDSP[2] =  recSqrt2;
                matrixDSP[3] =  recSqrt6;

                matrixDSP[4] =  0.5;
                matrixDSP[5] =  sqrt3Div6;
                matrixDSP[6] = -recSqrt2;
                matrixDSP[7] =  recSqrt6;

                matrixDSP[8] =  0.5;
                matrixDSP[9] =  sqrt3Div6;
                matrixDSP[10] =  0.;
                matrixDSP[11] = -sqrt6Div3;

                matrixDSP[12] =  0.5;
                matrixDSP[13] = -sqrt3Div2;
                matrixDSP[14] =  0.;
                matrixDSP[15] =  0.;
              ) :
              (
                // Option 7: front left-right down [ FLD, FRD, FU, B ]

                matrixDSP[0] =  0.5;
                matrixDSP[1] =  sqrt3Div6;
                matrixDSP[2] =  recSqrt2;
                matrixDSP[3] = -recSqrt6;

                matrixDSP[4] =  0.5;
                matrixDSP[5] =  sqrt3Div6;
                matrixDSP[6] = -recSqrt2;
                matrixDSP[7] = -recSqrt6;

                matrixDSP[8] =  0.5;
                matrixDSP[9] =  sqrt3Div6;
                matrixDSP[10] =  0.;
                matrixDSP[11] =  sqrt6Div3;

                matrixDSP[12] =  0.5;
                matrixDSP[13] = -sqrt3Div2;
                matrixDSP[14] =  0.;
                matrixDSP[15] =  0.;
              );

            );

          );

        );

      );
    );
  );


  // Weight:
  // Option 0: Decorrelated (on the sphere)
  weight == 0 ?
  (
    g0 = sqrt(2./3.);
  ) :
  (
    // Option 1: Canonical
    weight == 1 ?
    (
      g0 = 1.;
    ) :
    (
      // Option 2: Unscaled, W_gain = 1
      weight == 2 ?
      (
        g0 = sqrt(2.);
      ) :
      // Option 3: Cardioid
      (
        g0 = sqrt(6.);
      );
    );
  );

  // Compensate matrix for weight:
  matrixDSP[0] =  g0 * matrixDSP[0];
  matrixDSP[4] =  g0 * matrixDSP[4];
  matrixDSP[8] =  g0 * matrixDSP[8];
  matrixDSP[12] = g0 * matrixDSP[12];
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for directX transformation
********************************************************************/
function generateDirectMatrix(matrix, angle) local(g0, g1)
(
	g0 = sqrt(1 + sin(angle));
	g1 = sqrt(1 - sin(angle));
  
  matrix[0]  = g0;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g0;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g0;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for dominateX transformation
********************************************************************/
function generateDominateMatrix(matrix, gain) local(k, g0, g1)
(
	k = db2amp(gain);		
	g0 = (k + 1. / k) * 0.5;
	g1 = (k - 1. / k) / sqrt(2.);
    
  matrix[0]  = g0;
  matrix[1]  = g1 * 0.5;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g1;
  matrix[5]  = g0;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = 1.;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for tilt transformation
********************************************************************/
function generateFocusMatrix(matrix, angle) local(g0, g1, g2)
(  
	g0 = 1. / (1 + sin(abs(angle)));
	g1 = sqrt(2) *  sin(angle) * g0;
	g2 = cos(angle) * g0;
  
  matrix[0]  = g0;
  matrix[1]  = g1 * 0.5;
  matrix[2]  = 0.;
  matrix[3]  = 0.;

  matrix[4]  = g1; 
  matrix[5]  = g0;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g2;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g2;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for pressX transformation
********************************************************************/
function generatePressMatrix(matrix, angle) local(g0, g1, g2)
(
	g0 = sqrt(2.) * sin(angle) * sin(abs(angle));
  g2 = cos(angle);
  g1 = g2 * g2;
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g0;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g2;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g2;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for pushX transformation
********************************************************************/
function generatePushMatrix(matrix, angle) local(g0, g1)
(  
  g0 = sqrt(2.) * sin(angle) * sin(abs(angle));
  g1 = cos(angle);
  g1 = g1 * g1;
    
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g0;
  matrix[5]  = g1;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g1;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g1;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for rotation transformation
********************************************************************/
function generateRotationMatrix(matrix, angle)
(
  // We use SpatDIF (navigational) coordinate system rather than mathematical.
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = cos(angle);
  matrix[6]  = sin(angle);
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = -matrix[6];
  matrix[10] =  matrix[5];
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for tumble transformation
********************************************************************/
function generateTumblelMatrix(matrix, angle)
(  
  matrix[0]  =  1.;
  matrix[1]  =  0.;
  matrix[2]  =  0.;
  matrix[3]  =  0.;
  
  matrix[4]  =  0.;
  matrix[5]  =  cos(angle);
  matrix[6]  =  0.;
  matrix[7]  = -sin(angle);
  
  matrix[8]  =  0.;
  matrix[9]  =  0.;
  matrix[10] =  1.;
  matrix[11] =  0.;
  
  matrix[12] =  0.;
  matrix[13] = -matrix[7];
  matrix[14] =  0.;
  matrix[15] =  matrix[5];  
);


/********************************************************************
Matrix: Generate 1st order 4x4 matrix for zoomX transformation
********************************************************************/
function generateZoomMatrix(matrix, angle) local(g0, g1)
(
  g0 = sin(angle);
  g1 = cos(angle);
    
  matrix[0]  = 1.;
  matrix[1]  = g0 / sqrt(2.);
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = g0 * sqrt(2.);
  matrix[5]  = 1.;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = g1;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = g1;
);


/********************************************************************
Matrix: Multiplication of two 4x4 matrixes: result = left x right
********************************************************************/
function matrixMultiplication(resultMatrix, numRowsLeft, numColsLeft, leftMatrix, numRowsRight, numColsRight, rightMatrix)
(
  // It is the responsibility of each plugin calling this function to ensure that numColsLeft == numRowsRight.
  // We do not check for that here.
  
  // Iterate over rows of left matrix
  i = 0;
  loop(numRowsLeft, 
    // Iterate over columns of right matrix
    j = 0;
    loop(numColsRight,
      // Calculate one cell
      resultMatrix[numRowsLeft*i + j] = 0.;
      k = 0;
      loop(numColsLeft,
        resultMatrix[numRowsLeft*i + j] += leftMatrix[numRowsLeft*i + k] * rightMatrix[numRowsRight*k + j];
        k += 1;
      );
      j+= 1;
    );
    i+= 1;
  );
);


/********************************************************************
Matrix: Invert a 4x4 matrix
********************************************************************/
function invertMatrix(matrix)
(
  inv[0] =   matrix[5]  * matrix[10] * matrix[15] -
             matrix[5]  * matrix[11] * matrix[14] -
             matrix[9]  * matrix[6]  * matrix[15] +
             matrix[9]  * matrix[7]  * matrix[14] +
             matrix[13] * matrix[6]  * matrix[11] -
             matrix[13] * matrix[7]  * matrix[10];

  inv[4] =  -matrix[4]  * matrix[10]  * matrix[15] +
             matrix[4]  * matrix[11]  * matrix[14] +
             matrix[8]  * matrix[6]  * matrix[15] -
             matrix[8]  * matrix[7]  * matrix[14] -
             matrix[12] * matrix[6]  * matrix[11] +
             matrix[12] * matrix[7]  * matrix[10];

  inv[8] =   matrix[4]  * matrix[9]  * matrix[15] -
             matrix[4]  * matrix[11] * matrix[13] -
             matrix[8]  * matrix[5]  * matrix[15] +
             matrix[8]  * matrix[7]  * matrix[13] +
             matrix[12] * matrix[5]  * matrix[11] -
             matrix[12] * matrix[7]  * matrix[9];

  inv[12] = -matrix[4]  * matrix[9]  * matrix[14] +
             matrix[4]  * matrix[10] * matrix[13] +
             matrix[8]  * matrix[5]  * matrix[14] -
             matrix[8]  * matrix[6]  * matrix[13] -
             matrix[12] * matrix[5]  * matrix[10] +
             matrix[12] * matrix[6]  * matrix[9];

  inv[1] =  -matrix[1]  * matrix[10] * matrix[15] +
             matrix[1]  * matrix[11] * matrix[14] +
             matrix[9]  * matrix[2]  * matrix[15] -
             matrix[9]  * matrix[3]  * matrix[14] -
             matrix[13] * matrix[2]  * matrix[11] +
             matrix[13] * matrix[3]  * matrix[10];

  inv[5] =   matrix[0]  * matrix[10] * matrix[15] -
             matrix[0]  * matrix[11] * matrix[14] -
             matrix[8]  * matrix[2]  * matrix[15] +
             matrix[8]  * matrix[3]  * matrix[14] +
             matrix[12] * matrix[2]  * matrix[11] - 
             matrix[12] * matrix[3]  * matrix[10];

  inv[9] =  -matrix[0]  * matrix[9]  * matrix[15] +
             matrix[0]  * matrix[11] * matrix[13] +
             matrix[8]  * matrix[1]  * matrix[15] -
             matrix[8]  * matrix[3]  * matrix[13] -
             matrix[12] * matrix[1]  * matrix[11] +
             matrix[12] * matrix[3]  * matrix[9];

  inv[13] =  matrix[0]  * matrix[9]  * matrix[14] -
             matrix[0]  * matrix[10] * matrix[13] -
             matrix[8]  * matrix[1]  * matrix[14] +
             matrix[8]  * matrix[2]  * matrix[13] +
             matrix[12] * matrix[1]  * matrix[10] -
             matrix[12] * matrix[2]  * matrix[9];

  inv[2] =   matrix[1]  * matrix[6]  * matrix[15] -
             matrix[1]  * matrix[7]  * matrix[14] -
             matrix[5]  * matrix[2]  * matrix[15] +
             matrix[5]  * matrix[3]  * matrix[14] +
             matrix[13] * matrix[2]  * matrix[7] -
             matrix[13] * matrix[3]  * matrix[6];

  inv[6] =  -matrix[0]  * matrix[6]  * matrix[15] +
             matrix[0]  * matrix[7]  * matrix[14] +
             matrix[4]  * matrix[2]  * matrix[15] -
             matrix[4]  * matrix[3]  * matrix[14] -
             matrix[12] * matrix[2]  * matrix[7] +
             matrix[12] * matrix[3]  * matrix[6];

  inv[10] =  matrix[0]  * matrix[5]  * matrix[15] -
             matrix[0]  * matrix[7]  * matrix[13] -
             matrix[4]  * matrix[1]  * matrix[15] +
             matrix[4]  * matrix[3]  * matrix[13] +
             matrix[12] * matrix[1]  * matrix[7] -
             matrix[12] * matrix[3]  * matrix[5];

  inv[14] = -matrix[0]  * matrix[5]  * matrix[14] +
             matrix[0]  * matrix[6]  * matrix[13] +
             matrix[4]  * matrix[1]  * matrix[14] -
             matrix[4]  * matrix[2]  * matrix[13] -
             matrix[12] * matrix[1]  * matrix[6] +
             matrix[12] * matrix[2]  * matrix[5];

  inv[3] =  -matrix[1]  * matrix[6]  * matrix[11] +
             matrix[1]  * matrix[7]  * matrix[10] +
             matrix[5]  * matrix[2]  * matrix[11] -
             matrix[5]  * matrix[3]  * matrix[10] -
             matrix[9]  * matrix[2]  * matrix[7] +
             matrix[9]  * matrix[3]  * matrix[6];

  inv[7] =   matrix[0]  * matrix[6]  * matrix[11] -
             matrix[0]  * matrix[7]  * matrix[10] -
             matrix[4]  * matrix[2]  * matrix[11] +
             matrix[4]  * matrix[3]  * matrix[10] +
             matrix[8]  * matrix[2]  * matrix[7] -
             matrix[8]  * matrix[3]  * matrix[6];

  inv[11] = -matrix[0]  * matrix[5]  * matrix[11] +
             matrix[0]  * matrix[7]  * matrix[9] +
             matrix[4]  * matrix[1]  * matrix[11] -
             matrix[4]  * matrix[3]  * matrix[9] -
             matrix[8]  * matrix[1]  * matrix[7] +
             matrix[8]  * matrix[3]  * matrix[5];

  inv[15] =  matrix[0]  * matrix[5]  * matrix[10] -
             matrix[0]  * matrix[6]  * matrix[9] -
             matrix[4]  * matrix[1]  * matrix[10] +
             matrix[4]  * matrix[2]  * matrix[9] +
             matrix[8]  * matrix[1]  * matrix[6] -
             matrix[8]  * matrix[2]  * matrix[5];
					
  determinant = matrix[0] * inv[0] +
	              matrix[1] * inv[4] +
				        matrix[2] * inv[8] +
				        matrix[3] * inv[12];

  /* Might be difficult to check this in Reaper/JS, but it might also be redundant?
	if (determinant == 0)
    return false;
	*/

  determinant = 1.0 / determinant;

  matrix[0]  = inv[0]  * determinant;
	matrix[1]  = inv[1]  * determinant;
	matrix[2]  = inv[2]  * determinant;
	matrix[3]  = inv[3]  * determinant;
	
	matrix[4]  = inv[4]  * determinant;
	matrix[5]  = inv[5]  * determinant;
	matrix[6]  = inv[6]  * determinant;
	matrix[7]  = inv[7]  * determinant;
	
	matrix[8]  = inv[8]  * determinant;
	matrix[9]  = inv[9]  * determinant;
	matrix[10] = inv[10] * determinant;
	matrix[11] = inv[11] * determinant;
	
	matrix[12] = inv[12] * determinant;
	matrix[13] = inv[13] * determinant;
	matrix[14] = inv[14] * determinant;
	matrix[15] = inv[15] * determinant;
);





/*---------------------------------------------------------------------
  Graphics section
---------------------------------------------------------------------*/


/********************************************************************
Graphics: Set drawing color
********************************************************************/
function gxColorSet(alpha, red, green, blue)
(
	gfx_a = alpha;
	gfx_r = red;
	gfx_g = green;
	gfx_b  = blue;
);


/********************************************************************
Graphics: Set drawing position
********************************************************************/
function gxPositionSet(x, y)
(
	gfx_x = x;
	gfx_y = y;
);


/********************************************************************
Graphics: Determine geometry
********************************************************************/
function determineGeometry()
(
  centerX = gfx_w  * 0.5;
  centerY = gfx_h * 0.5;

  centerX < centerY ? radius = centerX : radius = centerY;
  radius = radius - 10;
  inverseRadius = 1. / radius;
);


/********************************************************************
Graphics: Draw background image based on ICST ambimonitor
********************************************************************/
function drawBackgroundImage()
(
  // Background graphics
  coordinatelist[0] = 0;                  //left-most pixel location for source
  coordinatelist[1] = 0;                  //top-most pixel location for source
  coordinatelist[2] = 800;                //width of source
  coordinatelist[3] = 800;                //height of source
  coordinatelist[4] = centerX - radius;   //left-most pixel location of destination
  coordinatelist[5] = centerY - radius;   //top-most pixel location of destination
  coordinatelist[6] = 2 * radius;         //width of destination to fill
  coordinatelist[7] = 2 * radius;         //height of destination to fill
  coordinatelist[8] =0;                   //represents offset from center of image
  coordinatelist[9] =0;                   //represents offset from center of image
  gfx_blitext(0,coordinatelist,0);
);


/********************************************************************
Graphics: Draw centered filled-in square
********************************************************************/
function drawCenteredSquare(centerX, centerY, squareSize) local(halfSize)
(
  halfSize = squareSize * 0.5;
  gfx_x = centerX - halfSize;
  gfx_y = centerY - halfSize;
  gfx_rectto(centerX + halfSize, centerY + halfSize);
);


/********************************************************************
Graphics: Draw outline of polygon with four sides and four corners
********************************************************************/
function drawQuadrangleOutline(position1x, position1y, position2x, position2y, position3x, position3y, position4x, position4y, antiAliasing)
(
  gfx_x = position1x;
  gfx_y = position1y;
  gfx_lineto(position2x, position2y, antiAliasing);
  gfx_lineto(position3x, position3y, antiAliasing);
  gfx_lineto(position4x, position4y, antiAliasing);
  gfx_lineto(position1x, position1y, antiAliasing);
);