/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: FocusPushPress
  First Order Ambisonic (FOA) focus, push and press transformer
---------------------------------------------------------------------
*/


desc: First Order Ambisonic focus, push and press transformer

in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

slider1:0<0,2,1{Focus, Push, Press}>Transformation mode
slider2:0<-180,180,1>Azimuth
slider3:0<-90,90,1>Elevation
slider4:0<-1,1,0.01>Degree of transform

// Debug sliders:
slider5:0<0,1,1{GUI, Debug}>Display mode
slider6:0<0,7,1{matrixRotate1, matrixTilt1, matrixTransform, matrixTilt2, matrixRotate2, matrixDSP, matrixNewDSP, matrixInc}>Matrix to display


/**********************************************************
Initialisation
**********************************************************/
@init

// Flag indicating that the plugin has not been fully initialised yet
initialised = 0;

azimuth   = 0;
elevation = 0.;

// Constants
rad2deg = 180. / $pi;
deg2rad = $pi / 180.;
sqrt2   = sqrt(2.);
rsqrt2  = 1. / sqrt2;

// Setting memory locations for a number of 4x4 matrixes as 1D arrays
matrixRotate1   = 1000;
matrixTilt1     = 1020;
matrixTransform = 1040;
matrixTilt2     = 1060;
matrixRotate2   = 1080;

// These are used for matrix multiplications
matrixTemp1     = 1100;
matrixTemp2     = 1120;

// Resulting matrixes used for DSP processing
matrixDSP       = 1200;
matrixNewDSP    = 1220;
matrixInc       = 1240;

function generateRotationMatrix(matrix, angle)
(
  // We use SpatDIF (navigational) coordinate system rather than mathematical.
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = cos(angle);
  matrix[6]  = sin(angle);
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = -matrix[6];
  matrix[10] =  matrix[5];
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);

function generateTiltlMatrix(matrix, angle)
(
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = 1.;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] =  cos(angle);
  matrix[11] = -sin(angle);
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = -matrix[11];
  matrix[15] =  matrix[10];  
);

function generateFocusMatrix(matrix, angle)
(
  cosa = cos(angle);
  sina = sin(angle);
  roneplussinaa = 1. / (1. + sin(abs(angle)));
  sina1sina = sina * roneplussinaa;
  
  matrix[0]  = roneplussinaa;
  matrix[1]  = rsqrt2 * sina1sina;
  matrix[2]  = 0.;
  matrix[3]  = 0.;

  matrix[4]  = sqrt2 * sina1sina; 
  matrix[5]  = roneplussinaa;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = cosa * roneplussinaa;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = cosa * roneplussinaa;
);

function generatePushMatrix(matrix, angle)
(
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = 1.;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = 1.;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);

function generatePressMatrix(matrix, angle)
(
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = 1.;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = 1.;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);

function matrixMultiplication(result, left, right)
(
  // Iterate over columns of left matrix
  i = 0;
  loop(4, 
    // Iterate over rows of right matrix
    j = 0;
    loop(4,
      // Calculate one cell
      result[4*i+j] = 0.;
      k = 0;
      loop(4,
        result[4*i+j] += left[4*i+k]*right[4*k+j];
        k += 1;
      );
      j+= 1;
    );
    i+= 1;
  );
);


function calculateMatrix()
(
  generateRotationMatrix(matrixRotate1, (-azimuth));
  generateTiltlMatrix(matrixTilt1, -elevation);
  mode == 0 ?
  (
    generateFocusMatrix(matrixTransform, transformAngle);
  )
 :
  (
    mode == 1 ?
    (
      generatePushMatrix(matrixTransform, transformAngle)
    )
    :
    (
      generatePressMatrix(matrixTransform, transformAngle)
    );
  );
  generateRotationMatrix(matrixRotate2, azimuth);
  generateTiltlMatrix(matrixTilt2, elevation);
  
  /* Matrix multiplications: result = left x right
                        result:          left:              right:             */
  matrixMultiplication  (matrixTemp1,    matrixTilt1,      matrixRotate1);
  matrixMultiplication  (matrixTemp2,    matrixTransform,  matrixTemp1);
  matrixMultiplication  (matrixTemp1,    matrixTilt2,      matrixTemp2);
  matrixMultiplication  (matrixNewDSP,   matrixRotate2,    matrixTemp1);
  
  // Set initial DSP processing coefficients if the plugin has not yet been initialised
  initialised == 0 ?
  (
    i = 0;
    loop(16,
      matrixDSP[i] = matrixNewDSP[i];
    );
    // Now we are fully initialised
    initialised = 1;
  );
);


/**********************************************************
Updated slider value:
**********************************************************/
@slider

mode            = slider1;
azimuth         = slider2 * deg2rad;
elevation       = slider3 * deg2rad;
transformAngle  = slider4 * 3.14159265359 * 0.5;


slider6 == 0 ?
(
  viewMatrix = matrixRotate1;
) :
(
  slider6 == 1 ?
  (
    viewMatrix = matrixTilt1;
  ) :
  (
    slider6 == 2 ?
    (
      viewMatrix = matrixTransform;
    ) :
    (
      slider6 == 3 ?
      (
        viewMatrix = matrixTilt2;
      ) :
      (
        slider6 == 4 ?
        (
          viewMatrix = matrixRotate2;
        ) :
        (
          slider6 == 5 ?
          (
            viewMatrix = matrixDSP;
          ) :
          (
            slider6 == 6 ?
            (
              viewMatrix = matrixNewDSP;
            ) :
            (
              viewMatrix = matrixInc;
            );
          );
        );
      );
    );
  );
);


calculateMatrix();



/**********************************************************
Graphics
**********************************************************/
@gfx [300] [600]

function gxColorSet(alpha, red, green, blue)
(
	gfx_a = alpha;
	gfx_r = red;
	gfx_g = green;
	gfx_b  = blue;
);

function gxPositionSet(x, y)
(
	gfx_x = x;
	gfx_y = y;
);

gxColorSet(1., 1., 1., 1.);


// Iterate over columns:
iii = 0;
loop(4,
  // Iterate over rows
  jjj = 0;
  loop(4,
    gxPositionSet(iii*80 + 40, jjj*20 + 20);
    gfx_drawnumber( viewMatrix[iii + 4*jjj],5);
    jjj = jjj + 1;
  );
  iii = iii + 1;
);


/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

inverseSamplesblock = 1. / samplesblock;

// Counter is called "ii" rather than "i" in order to ensure that we do not use the same counter here as in other sections
ii = 0;
loop(16,
  matrixInc[ii] = (matrixNewDSP[ii] - matrixDSP[ii]) * inverseSamplesblock;
  ii += 1;
);


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

ii = 0;
loop(16,
  matrixDSP[ii] += matrixInc[ii];
  ii += 1;
);

wIn = spl0;
xIn = spl1;
yIn = spl2;
zIn = spl3;

// Matrix multiplication with input signal:
spl0 = wIn * matrixDSP[0] + xIn  * matrixDSP[1]  + yIn * matrixDSP[2]  + zIn * matrixDSP[3];
spl1 = wIn * matrixDSP[4] + xIn  * matrixDSP[5]  + yIn * matrixDSP[6]  + zIn * matrixDSP[7];
spl2 = wIn * matrixDSP[8] + xIn  * matrixDSP[9]  + yIn * matrixDSP[10] + zIn * matrixDSP[11];
spl3 = wIn * matrixDSP[12] + xIn * matrixDSP[13] + yIn * matrixDSP[14] + zIn * matrixDSP[15];
