// -------------------------------------------------------
// ATK (Sandbox)
//
// New decoders--using the decoders generated by ATKMatrix.sc
//
//
// Coded by Joseph Anderson 2011
//
// -------------------------------------------------------



//------------------------------------------------------------------------// Muse/ATK decoders built using the above decoder gain matrices//   Developed and coded by J Anderson//////   ++++ Single Band Regular Decoders////   panto_sbr//   peri_sbr////   ++++ Single Band Diametric Decoders////   decode_sbd//   quad_sbd//////   ++++ Dual Band Regular Decoders (Shelf-filtered)////   panto_dbr//   peri_dbr////   ++++ Dual Band Diametric Decoders (Shelf-filtered)////   decode_dbd//   quad_dbd        (See special decoders)////------------------------------------------------------------------------


// -------------------------------------------------------
// test (decoders built using Mix.ar)
//
// shelf filtering, if required, is built into decoder
// specify use through matrix choice
//
// -------------------------------------------------------
// quad (spec'd as narrow quad)
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, angle, k;

	// constants
	angle = pi/6;
//	k = 1;					// velocity, or 'strict' soundfield
//	k = 1/2.sqrt;				// energy, for 2D
//	k = 1/2;					// controlled opposites, for 2D
//	k = 'velocity';			// velocity
//	k = 'energy';				// energy
//	k = 'controlled';			// controlled opposites
//	k = 'single';				// synonym for energy
	k = 'dual';				// dual band

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newQuad(angle, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#fl, bl, br, fr = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

// diametric (spec'd as narrow quad)
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, directions, k;

	// constants
	directions = [ pi/6, -pi/6 ];
//	k = 1;					// velocity, or 'strict' soundfield
//	k = 1/2.sqrt;				// energy, for 2D
//	k = 1/2;					// controlled opposites, for 2D
//	k = 'velocity';			// velocity
//	k = 'energy';				// energy
//	k = 'controlled';			// controlled opposites
//	k = 'single';				// synonym for energy
	k = 'dual';				// dual band

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newDiametric(directions, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#fl, fr, br, bl = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

// panto (spec'd as quad)
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, numSpeakers, orientation, k;

	// constants
	numSpeakers = 4;
	orientation = 'flat';
//	k = 1;					// velocity, or 'strict' soundfield
//	k = 1/2.sqrt;				// energy, for 2D
//	k = 1/2;					// controlled opposites, for 2D
//	k = 'velocity';			// velocity
//	k = 'energy';				// energy
//	k = 'controlled';			// controlled opposites
//	k = 'single';				// synonym for energy
	k = 'dual';				// dual band

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newPanto(numSpeakers, orientation, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#fl, bl, br, fr = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

// peri (spec'd as cube)
// mono pink noise, sound synth function
(
{
	var	flu, blu, bru, fru, fld, bld, brd, frd;		// for cube output
	var	azim, sig;
	var	decoderMatrix, numSpeakerPairs, elevation, orientation, k;

	// constants
	numSpeakerPairs = 4;
	elevation = pi/6;
	orientation = 'flat';
//	k = 1;					// velocity, or 'strict' soundfield
//	k = 1/3.sqrt;				// energy, for 3D
//	k = 1/3;					// controlled opposites, for 3D
//	k = 'velocity';			// velocity
//	k = 'energy';				// energy
//	k = 'controlled';			// controlled opposites
//	k = 'single';				// synonym for energy
	k = 'dual';				// dual band

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newPeri(numSpeakerPairs, elevation, orientation, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#flu, blu, bru, fru, fld, bld, brd, frd = AtkDecode.ar(sig, decoderMatrix);

	[flu, fru, blu, bru]		// reorder output to match speaker arrangement
//	[fld, frd, bld, brd]		// reorder output to match speaker arrangement

}.scope;
)

// stereo
// mono pink noise, sound synth function
(
{
	var	azim, sig;
	var	decoderMatrix, angle, pattern;

	// constants
	angle = pi/2;
	pattern = 0.5;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newStereo(angle, pattern);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	AtkDecode.ar(sig, decoderMatrix);

}.scope;
)

// mono
// mono pink noise, sound synth function
(
{
	var	azim, sig;
	var	decoderMatrix, theta, phi, pattern;

	// constants
	theta = phi = 0;
	pattern = 0.5;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newMono(theta, phi, pattern);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	AtkDecode.ar(sig, decoderMatrix);

}.scope;
)




// -------------------------------------------------------
// test for kernel type decoders
//
// -------------------------------------------------------

// uhj test
// mono pink noise, sound synth function
(
{
	var	azim, sig;
	var	decoderKernel;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up kernel
	decoderKernel = AtkDecoderKernel.newUHJ;

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	AtkDecode.ar(sig, a);
//	AtkDecode.ar(0, a);
//	AtkDecode.ar(sig, decoderKernel);

}.scope;
//}
)

a.kernel.at(0).at(0)

a.kernel.shape.at(0)
a.kernel.shape.at(1)
a.kernel.at(0).at(0).numFrames

a.kernel.shape
b.shape