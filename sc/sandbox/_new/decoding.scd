// -------------------------------------------------------
// ATK (Sandbox)
//
// New decoders--using the decoders generated by ATKMatrix.sc
//
//
// Coded by Joseph Anderson 2011
//
// -------------------------------------------------------



//------------------------------------------------------------------------// Muse/ATK decoders built using the above decoder gain matrices//   Developed and coded by J Anderson//////   ++++ Single Band Regular Decoders////   panto_sbr//   peri_sbr////   ++++ Single Band Diametric Decoders////   decode_sbd//   quad_sbd//////   ++++ Dual Band Regular Decoders (Shelf-filtered)////   panto_dbr//   peri_dbr////   ++++ Dual Band Diametric Decoders (Shelf-filtered)////   decode_dbd//   quad_dbd        (See special decoders)////------------------------------------------------------------------------

//------------------------------------------------------------------------// Single Band Regular Decoders////   panto_sbr           pantophonic//   peri_sbr            periphonic//------------------------------------------------------------------------

//------------------------------------------------------------------------// Single Band Diametric Decoder////   decode_sbd//   quad_sbd//------------------------------------------------------------------------


// -------------------------------------------------------
// test (decoders built using Mix.ar)
//
// -------------------------------------------------------
// quad (spec'd as narrow quad)
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, angle, k;

	// constants
	angle = pi/6;
	k = 1;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newQuad(angle, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#fl, bl, br, fr = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

// diametric (spec'd as narrow quad)
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, directions, k;

	// constants
	directions = [ pi/6, -pi/6 ];
	k = 1;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newDiametric(directions, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#fl, fr, br, bl = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

// panto (spec'd as quad)
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, numSpeakers, orientation, k;

	// constants
	numSpeakers = 4;
	orientation = 'flat';
	k = 1;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newPanto(numSpeakers, orientation, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#fl, bl, br, fr = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

// peri (spec'd as cube)
// mono pink noise, sound synth function
(
{
	var	flu, blu, bru, fru, fld, bld, brd, frd;		// for cube output
	var	azim, sig;
	var	decoderMatrix, numSpeakerPairs, elevation, orientation, k;

	// constants
	numSpeakerPairs = 4;
	elevation = pi/6;
	orientation = 'flat';
	k = 1;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newPeri(numSpeakerPairs, elevation, orientation, k);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	#flu, blu, bru, fru, fld, bld, brd, frd = AtkDecode.ar(sig, decoderMatrix);

	[flu, fru, blu, bru]		// reorder output to match speaker arrangement
//	[fld, frd, bld, brd]		// reorder output to match speaker arrangement

}.scope;
)

// stereo
// mono pink noise, sound synth function
(
{
	var	azim, sig;
	var	decoderMatrix, angle, pattern;

	// constants
	angle = pi/2;
	pattern = 0.5;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newStereo(angle, pattern);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	AtkDecode.ar(sig, decoderMatrix);

}.scope;
)

// mono
// mono pink noise, sound synth function
(
{
	var	azim, sig;
	var	decoderMatrix, theta, phi, pattern;

	// constants
	theta = phi = 0;
	pattern = 0.5;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newMono(theta, phi, pattern);

	// test sig
	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise


	// decode to output
	AtkDecode.ar(sig, decoderMatrix);

}.scope;
)



//------------------------------------------------------------------------
// Dual Band Regular Decoders
//
//   panto_dbr           pantophonic
//   peri_dbr            periphonic
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Dual Band Diametric Decoder
//
//   decode_dbd
//   quad_dbd
//------------------------------------------------------------------------

// -------------------------------------------------------
// test (decoders built using Mix.ar)
//
// -------------------------------------------------------
// quad (spec'd as narrow quad)
// dual band test dev
// mono pink noise, sound synth function
(
{
	var	fl, bl, br, fr;					// for quad output
	var	azim, sig;
	var	decoderMatrix, angle, k;

	// constants
	angle = pi/6;
	k = 1;

	// kr....
	azim = MouseX.kr(pi, -pi);


	// set up matrix
	decoderMatrix = AtkDecoderMatrix.newQuad(angle, k);

	// test sig
//	sig = AtkMonoToB.ar(PinkNoise.ar, azim); // mono pink noise
	sig = PinkNoise.ar;
	#w, x, y, z = AtkMonoToB.ar(sig, azim); // mono pink noise

	// test psychoShelf
	sig = AtkPsychoShelf.ar(w, x, y, z, 400, [(3/2).sqrt, 3.sqrt/2]);

	// decode to output
	#fl, bl, br, fr = AtkDecode.ar(sig, decoderMatrix);

	[fl, fr, bl, br]		// reorder output to match speaker arrangement

}.scope;
)

