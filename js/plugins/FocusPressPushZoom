/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: FocusPushPress
  First Order Ambisonic (FOA) focus, push and press transformer
---------------------------------------------------------------------
*/


/* --- DEBUG STUFF ---

This plugin contains some code that ight be useful for debugging,
providing an alternative GUI displaying the content of various matrixes.
For regular use of the plugin the debug code is commented out in the same way as here.

--- DEBUG STUFF --- */


desc: First Order Ambisonic focus, push and press transformer

filename:0,HorizontalBackground.png

in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

slider1:0<0,3,1{Focus, Press, Push, Zoom}>Transformation mode
slider2:0<-180,180,1>Azimuth (mouse)
slider3:0<-90,90,1>Elevation
slider4:0<0,1,0.01>Degree of transformation (mouse)

/* --- DEBUG STUFF ---
// Debug sliders:
// slider5:0<0,1,1{GUI, Debug}>Display mode
// slider6:0<0,7,1{matrixRotate1, matrixTumble1, matrixTransform, matrixTumble2, matrixRotate2, matrixDSP, matrixNewDSP, matrixInc}>Matrix to display
--- DEBUG STUFF --- */



/**********************************************************
Initialisation
**********************************************************/
@init

// Flag indicating that the plugin has not been fully initialised yet
initialised = 0;

azimuth   = 0;
elevation = 0.;

// Constants
rad2deg = 180. / $pi;
deg2rad = $pi / 180.;
sqrt2   = sqrt(2.);
rsqrt2  = 1. / sqrt2;

// Setting memory locations for a number of 4x4 matrixes as 1D arrays
matrixRotate1   = 1000;
matrixTumble1     = 1020;
matrixTransform = 1040;
matrixTumble2     = 1060;
matrixRotate2   = 1080;

// These are used for matrix multiplications
matrixTemp1     = 1100;
matrixTemp2     = 1120;

// Resulting matrixes used for DSP processing
matrixDSP       = 1200;
matrixNewDSP    = 1220;
matrixInc       = 1240;

function generateRotationMatrix(matrix, angle)
(
  // We use SpatDIF (navigational) coordinate system rather than mathematical.
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = 0.;
  matrix[5]  = cos(angle);
  matrix[6]  = sin(angle);
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = -matrix[6];
  matrix[10] =  matrix[5];
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = 1.;
);

function generateTumblelMatrix(matrix, angle)
(  
  matrix[0]  =  1.;
  matrix[1]  =  0.;
  matrix[2]  =  0.;
  matrix[3]  =  0.;
  
  matrix[4]  =  0.;
  matrix[5]  =  cos(angle);
  matrix[6]  =  0.;
  matrix[7]  = -sin(angle);
  
  matrix[8]  =  0.;
  matrix[9]  =  0.;
  matrix[10] =  1.;
  matrix[11] =  0.;
  
  matrix[12] =  0.;
  matrix[13] = -matrix[7];
  matrix[14] =  0.;
  matrix[15] =  matrix[5];  
);

function generateFocusMatrix(matrix, angle)
(
  cosa = cos(angle);
  sina = sin(angle);
  roneplussinaa = 1. / (1. + sin(abs(angle)));
  sina1sina = sina * roneplussinaa;
  
  matrix[0]  = roneplussinaa;
  matrix[1]  = rsqrt2 * sina1sina;
  matrix[2]  = 0.;
  matrix[3]  = 0.;

  matrix[4]  = sqrt2 * sina1sina; 
  matrix[5]  = roneplussinaa;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = cosa * roneplussinaa;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = cosa * roneplussinaa;
);

function generatePressMatrix(matrix, angle)
(
  cosa = cos(angle);
  sina = sin(angle);
  cosa2 = cosa * cosa;
  asina = sin(abs(angle));
  sqrt2asinasina = sqrt2 * (asina * sina);
    
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = sqrt2asinasina;
  matrix[5]  = cosa2;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = cosa;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = cosa;
  matrix[15] = 1.;
);

function generatePushMatrix(matrix, angle)
(
  cosa = cos(angle);
  sina = sin(angle);
  
  cosa2 = cosa * cosa;
  asina = sin(abs(angle));
  sqrt2asinasina = sqrt2 * (asina * sina);
  
  matrix[0]  = 1.;
  matrix[1]  = 0.;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = sqrt2asinasina;
  matrix[5]  = cosa2;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = cosa2;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = 0.;
  matrix[15] = cosa2;
);

function generateZoomMatrix(matrix, angle)
(  
  cosa = cos(angle);
  sina = sin(angle);
    
  matrix[0]  = 1.;
  matrix[1]  = rsqrt2 * sina;
  matrix[2]  = 0.;
  matrix[3]  = 0.;
  
  matrix[4]  = sqrt2 * sina;
  matrix[5]  = 1.;
  matrix[6]  = 0.;
  matrix[7]  = 0.;
  
  matrix[8]  = 0.;
  matrix[9]  = 0.;
  matrix[10] = cosa;
  matrix[11] = 0.;
  
  matrix[12] = 0.;
  matrix[13] = 0.;
  matrix[14] = cosa;
  matrix[15] = 1.;
);



function matrixMultiplication(result, left, right)
(
  // Iterate over columns of left matrix
  i = 0;
  loop(4, 
    // Iterate over rows of right matrix
    j = 0;
    loop(4,
      // Calculate one cell
      result[4*i+j] = 0.;
      k = 0;
      loop(4,
        result[4*i+j] += left[4*i+k]*right[4*k+j];
        k += 1;
      );
      j+= 1;
    );
    i+= 1;
  );
);


function calculateMatrix()
(
  // Required for graphics
  cosAzimuth   = cos(azimuth);
  sinAzimuth   = sin(azimuth);

  cosElevation = cos(elevation);
  sinElevation = sin(elevation);
  
  // Generate matrixes
  generateRotationMatrix(matrixRotate1, (-azimuth));
  generateTumblelMatrix(matrixTumble1, -elevation);
  
  // Determine what transform to do
  mode == 0 ? (
    generateFocusMatrix(matrixTransform, transformAngle);
  ) : (
    mode == 1 ? (
      generatePressMatrix(matrixTransform, transformAngle)
    ) : (
      mode == 2? (
        generatePushMatrix(matrixTransform, transformAngle)
      ) : (
        generateZoomMatrix(matrixTransform, transformAngle)
      );
    );
  );
  generateRotationMatrix(matrixRotate2, azimuth);
  generateTumblelMatrix(matrixTumble2, elevation);
  
  /* Build processing matrix by performing a series of matrix multiplications
                        result =         left     X         right             */
  matrixMultiplication  (matrixTemp1,    matrixTumble1,     matrixRotate1);
  matrixMultiplication  (matrixTemp2,    matrixTransform,   matrixTemp1);
  matrixMultiplication  (matrixTemp1,    matrixTumble2,     matrixTemp2);
  matrixMultiplication  (matrixNewDSP,   matrixRotate2,     matrixTemp1);
  
  // Set initial DSP processing coefficients if the plugin has not yet been initialised
  initialised == 0 ?
  (
    i = 0;
    loop(16,
      matrixDSP[i] = matrixNewDSP[i];
    );
    // Now we are fully initialised
    initialised = 1;
  );
);


/**********************************************************
Updated slider value:
**********************************************************/
@slider

mode            = slider1;
azimuth         = slider2 * deg2rad;
elevation       = slider3 * deg2rad;
transformAngle  = slider4 * 3.14159265359 * 0.5;

/* --- DEBUG STUFF ---
debugMode       = slider5;

slider6 == 0 ?
(
  viewMatrix = matrixRotate1;
) : (
  slider6 == 1 ? (
    viewMatrix = matrixTumble1;
  ) : (
    slider6 == 2 ? (
      viewMatrix = matrixTransform;
    ) : (
      slider6 == 3 ? (
        viewMatrix = matrixTumble2;
      ) : (
        slider6 == 4 ? (
          viewMatrix = matrixRotate2;
        ) : (
          slider6 == 5 ? (
            viewMatrix = matrixDSP;
          ) : (
            slider6 == 6 ? (
              viewMatrix = matrixNewDSP;
            ) : (
              viewMatrix = matrixInc;
            );
          );
        );
      );
    );
  );
);

--- DEBUG STUFF --- */

calculateMatrix();



/**********************************************************
Graphics
**********************************************************/
@gfx 500 500

function gxColorSet(alpha, red, green, blue)
(
	gfx_a = alpha;
	gfx_r = red;
	gfx_g = green;
	gfx_b  = blue;
);

function gxPositionSet(x, y)
(
	gfx_x = x;
	gfx_y = y;
);

/* --- DEBUG STUFF ---
debugMode == 0 ?
(
--- DEBUG STUFF --- */

  // This is the regular interactive GUI mode:
  
  // Set colors
  gfx_a = 1;
  gfx_r = gfx_g = gfx_b = 1;

  // Determine geometry
  centerX = gfx_w  * 0.5;
  centerY = gfx_h * 0.5;

  centerX < centerY ? radius = centerX : radius = centerY;
  radius = radius - 10;
  inverseRadius = 1. / radius;

  // Background graphics
  coordinatelist[0] = 0;                  //left-most pixel location for source
  coordinatelist[1] = 0;                  //top-most pixel location for source
  coordinatelist[2] = 800;                //width of source
  coordinatelist[3] = 800;                //height of source
  coordinatelist[4] = centerX - radius;   //left-most pixel location of destination
  coordinatelist[5] = centerY - radius;   //top-most pixel location of destination
  coordinatelist[6] = 2 * radius;         //width of destination to fill
  coordinatelist[7] = 2 * radius;         //height of destination to fill
  coordinatelist[8] =0;                   //represents offset from center of image
  coordinatelist[9] =0;                   //represents offset from center of image
  gfx_blitext(0,coordinatelist,0);

  // Reset azimuth and transformAngle on mouse click
  mouse_cap == 1 ?
  (
    mouseX = mouse_x - centerX;
    mouseY = mouse_y - centerY;
    
    // Update azimuth and slider2 and notify GUI of the change
    azimuth = atan2(mouseX, -mouseY);
    slider2 = azimuth * rad2deg;
    slider_automate(slider2);
    
    // Update transformAngle and slider4 and notify GUI of the change
    slider4 = sqrt(mouseX*mouseX + mouseY*mouseY) * inverseRadius;
    // Restrict the range to [0, 1]
    slider4 > 1. ? slider4 = 1.;
    transformAngle = slider4 * $pi * 0.5;
    slider_automate(slider4);
    
    calculateMatrix();
  );
  
  posX = centerX + radius * slider4 * (sinAzimuth * cosElevation);
  posY = centerY - radius * slider4 * (cosAzimuth * cosElevation);

  // Red square as interactive direction indicator, color tint depends on elevation
  gfx_r =  1.0 + 0.3 * sinElevation;
  gfx_g =  0.5 * sinElevation;
  gfx_b =  0.5 * sinElevation;

  squareSize = 2. * sinElevation + 6.;

  gfx_x = posX-squareSize;
  gfx_y = posY-squareSize;
  gfx_rectto(posX+squareSize, posY+squareSize);
  
/* --- DEBUG STUFF ---  
) : (
  
  // Debug mode can be used to inspect the content of the various matrixes
  gxColorSet(1., 1., 1., 1.);

  // Iterate over columns:
  iii = 0;
  loop(4,
    // Iterate over rows
    jjj = 0;
    loop(4,
      gxPositionSet(iii*80 + 40, jjj*20 + 20);
      gfx_drawnumber( viewMatrix[iii + 4*jjj],5);
      jjj = jjj + 1;
    );
    iii = iii + 1;
  );
);
--- DEBUG STUFF --- */


/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

inverseSamplesblock = 1. / samplesblock;

// Counter is called "ii" rather than "i" in order to ensure that we do not use the same counter here as in other sections
ii = 0;
loop(16,
  matrixInc[ii] = (matrixNewDSP[ii] - matrixDSP[ii]) * inverseSamplesblock;
  ii += 1;
);


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

ii = 0;
loop(16,
  matrixDSP[ii] += matrixInc[ii];
  ii += 1;
);

wIn = spl0;
xIn = spl1;
yIn = spl2;
zIn = spl3;

// Matrix multiplication with input signal:
spl0 = wIn * matrixDSP[0] + xIn  * matrixDSP[1]  + yIn * matrixDSP[2]  + zIn * matrixDSP[3];
spl1 = wIn * matrixDSP[4] + xIn  * matrixDSP[5]  + yIn * matrixDSP[6]  + zIn * matrixDSP[7];
spl2 = wIn * matrixDSP[8] + xIn  * matrixDSP[9]  + yIn * matrixDSP[10] + zIn * matrixDSP[11];
spl3 = wIn * matrixDSP[12] + xIn * matrixDSP[13] + yIn * matrixDSP[14] + zIn * matrixDSP[15];
