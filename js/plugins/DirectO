/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: DirectO
  Adjust the soundfield directivity of a first order ambisonic signal (B-format) across the origin.
---------------------------------------------------------------------
*/


desc: Adjust the soundfield directivity of a first order ambisonic signal (B-format) across the origin.

/* Graphics are commented out for the time being until it might be used for illustration purposes

// Graphics file
//filename:0,HorizontalBackground.png

*/

// Import library with shared functions for matrix and graphics processing
import atkFunctionLibrary.jsfx-inc

in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

slider1:0<0,1,0.01>Degree of transformation


/**********************************************************
Initialisation
**********************************************************/
@init

// Flag indicating that the plugin has not been fully initialised yet
initialised = 0;



/**********************************************************
Updated slider value:
**********************************************************/
@slider

transformAngle  = slider1 * $pi * 0.5;

// Calculate g0 and g1 at initialisation
initialised == 0 ?
(
  g0 = sqrt(1 + sin(transformAngle));
  g1 = sqrt(1 - sin(transformAngle));
  // Now we are initialised
  initialised = 1;
)


/**********************************************************
Graphics
**********************************************************/

//@gfx 500 500

/* COMMENTED OUT

gxColorSet(1, 1, 1, 1);
determineGeometry();
drawBackgroundImage();

// Reset azimuth and transformAngle on mouse click
mouse_cap == 1 ?
(
  mouseX = mouse_x - centerX;
  mouseY = mouse_y - centerY;
  
  // Update azimuth and slider2 and notify GUI of the change
  azimuth = atan2(mouseX, -mouseY);
  slider2 = azimuth * rad2deg;
  slider_automate(slider2);
  
  // Update transformAngle and slider4 and notify GUI of the change
  slider4 = sqrt(mouseX*mouseX + mouseY*mouseY) * inverseRadius;
  // Restrict the range to [0, 1]
  slider4 > 1. ? slider4 = 1.;
  transformAngle = slider4 * $pi * 0.5;
  slider_automate(slider4);
  
  calculateMatrix();
);

// Draw red square as interactive direction indicator, size and color tint depends on elevation
gxColorSet(1, 1.0 + 0.3 * sinElevation, 0.5 * sinElevation, 0.5 * sinElevation);
posX = centerX + radius * slider4 * (sinAzimuth * cosElevation);
posY = centerY - radius * slider4 * (cosAzimuth * cosElevation);
squareSize = 4. * sinElevation + 12.;
drawCenteredSquare(posX, posY, squareSize);

*/

/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

inverseSamplesblock = 1. / samplesblock;

inc0 = (sqrt(1 + sin(transformAngle)) - g0) * inverseSamplesblock;
inc1 = (sqrt(1 - sin(transformAngle)) - g1) * inverseSamplesblock;


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

g0 = g0 + inc0;
g1 = g1 + inc1;

spl0 = spl0 * g0;
spl1 = spl1 * g1;
spl2 = spl2 * g1;
spl3 = spl3 * g1;
