/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: RotateTiltTumble
  First Order Ambisonic (FOA) multi-axes rotation transformer
---------------------------------------------------------------------
*/


desc: Rotate a first order ambisonic signal (B-format) around the z, x and y axes.

// Graphics file
filename:0,HorizontalBackground.png

// Import library with shared functions for matrix and graphics processing
import atkFunctionLibrary.jsfx-inc

in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

// Slider range is set to [-360,360] rather than [-180, 180] for more flexible scripting of rotating movements
slider1:0<-180,180,1>Rotate (mouse)
slider2:0<-180,180,1>Tilt (shift + mouse)
slider3:0<-180,180,1>Tumble (cmd + mouse)


/**********************************************************
Initialisation
**********************************************************/
@init

// Constants
rad2deg  = 180. / $pi;
deg2rad  = $pi / 180.;
rad2norm = 1. / $pi;

// Graphics constants:
squareSize = 10.;

// Flag indicating that the plugin has not been fully initialised yet
initialised = 0;

function calculateCoefficients()
(
  // We use SpatDIF (navigational) coordinate system rather than mathematical.
  // Hence we need to invert the sign of sinRotation
  cosRotation = cos(rotateAngle);
  sinRotation = sin(rotateAngle);
  
  cosTilt = cos(tiltAngle);
  sinTilt = sin(tiltAngle);
  
  // We use SpatDIF (navigational) coordinate system rather than mathematical.
  // Hence we need to invert the sign of sinTumble
  cosTumble = cos(tumbleAngle);
  sinTumble = sin(tumbleAngle);
  
  // Set coefficients if the plugin has not yet been initialised
  initialised == 0 ?
  (
    cosRotationDspCoeff = cosRotation;
    sinRotationDspCoeff = sinRotation;

    cosTiltDspCoeff = cosTilt;
    sinTiltDspCoeff = sinTilt;

    cosTumbleDspCoeff = cosTumble;
    sinTumbleDspCoeff = sinTumble;

    // Now we are fully initialised
    initialised = 1;
  );
);

/**********************************************************
Updated slider value:
**********************************************************/
@slider

rotateAngle = slider1 * deg2rad;
tiltAngle   = slider2 * deg2rad;
tumbleAngle = slider3 * deg2rad;

calculateCoefficients();


/**********************************************************
Custom graphic interface
**********************************************************/
@gfx 500 500

gxColorSet(1, 1, 1, 1);
determineGeometry();
drawBackgroundImage();

// Draw rotation indicator as interactive orange square
mouse_cap == 1 ?
(
  mouseX = mouse_x - centerX;
  mouseY = mouse_y - centerY;
  rotateAngle = atan2(mouseX, -mouseY);
  slider1 = rotateAngle * rad2deg;
  
  // Notify GUI that rotation has changed, and update coefficients
  slider_automate(slider1);
  calculateCoefficients();
);

gxColorSet(1, 1, 0.75, 0.5);
drawCenteredSquare(centerX + radius* sinRotation, centerY - radius*cosRotation, squareSize);

// Draw tilt indicator as interactive (shift + mouse) blue square and plane
mouse_cap == 9 ?
(
  mouseX = mouse_x - centerX;
  mouseX > radius ? mouseX = radius : 
  (
    mouseX < -radius ? mouseX = -radius;
  );
  tiltAngle = mouseX  * $pi / radius;
  slider2 = tiltAngle * rad2deg;
  
  // Notify GUI/automation that tilt has changed, and update coefficients
  slider_automate(slider2);
  calculateCoefficients();
);
gxColorSet(1, 0.5, 0.75, 1.);
drawCenteredSquare(centerX + tiltAngle * rad2norm * radius, centerY, squareSize);

// Draw outline of tilt plane - gray if the plane is tilted upside down
cosTilt < 0 ?
(
  gxColorSet(1, 0.7, 0.7, 0.7);
);

tiltDeltaX = radius * cosTilt;
tiltDeltaY = radius * sinTilt * 0.1;
radiusFraction = 0.2 * radius;

drawQuadrangleOutline(centerX - tiltDeltaX, centerY - radiusFraction - tiltDeltaY,
                      centerX + tiltDeltaX, centerY - radiusFraction + tiltDeltaY,
                      centerX + tiltDeltaX, centerY + radiusFraction - tiltDeltaY,
                      centerX - tiltDeltaX, centerY + radiusFraction + tiltDeltaY, 
                      1.);

// CMD + mouse: Draw tumble indicator as interactive green square
mouse_cap == 5 ?
(
  mouseY = centerY - mouse_y;
  mouseY > radius ? mouseY = radius : 
  (
    mouseY < -radius ? mouseY = -radius;
  );
  mouseY = mouseY * $pi / radius;
  tumbleAngle = mouseY;
  slider3 = tumbleAngle * rad2deg;
  
  // Notify GUI/automation that tumble has changed, and update coefficients
  slider_automate(slider3);
  calculateCoefficients();
);
gxColorSet(1, 0.5, 1., 0.75);
drawCenteredSquare(centerX, centerY - tumbleAngle * rad2norm * radius, squareSize);

// Draw outline of tumble plane - gray if the plane is tilted upside down
cosTumble < 0 ?
(
  gxColorSet(1, 0.7, 0.7, 0.7);
);

tumbleDeltaX = radius * sinTumble * 0.1;
tumbleDeltaY = radius * cosTumble;

drawQuadrangleOutline(centerX - radiusFraction - tumbleDeltaX, centerY - tumbleDeltaY,
                      centerX - radiusFraction + tumbleDeltaX, centerY + tumbleDeltaY,
                      centerX + radiusFraction - tumbleDeltaX, centerY + tumbleDeltaY,
                      centerX + radiusFraction + tumbleDeltaX, centerY - tumbleDeltaY,
                      1.);


/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

inverseSamplesblock = 1. / samplesblock;

// Linear ramp to new coefficient values over the vector to prevent clicks
incCosRotation = (cosRotation - cosRotationDspCoeff) * inverseSamplesblock;
incSinRotation = (sinRotation - sinRotationDspCoeff) * inverseSamplesblock;

incCosTilt  = (cosTilt - cosTiltDspCoeff) * inverseSamplesblock;
incSinTilt = (sinTilt - sinTiltDspCoeff) * inverseSamplesblock;

incCosTumble = (cosTumble - cosTumbleDspCoeff) * inverseSamplesblock;
incSinTumble = (sinTumble - sinTumbleDspCoeff) * inverseSamplesblock;


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

// Increment matric coefficients for linear interpolation
cosRotationDspCoeff = cosRotationDspCoeff + incCosRotation;
sinRotationDspCoeff = sinRotationDspCoeff + incSinRotation;

cosTiltDspCoeff = cosTiltDspCoeff + incCosTilt;
sinTiltDspCoeff = sinTiltDspCoeff + incSinTilt;

cosTumbleDspCoeff = cosTumbleDspCoeff + incCosTumble;
sinTumbleDspCoeff = sinTumbleDspCoeff + incSinTumble;

// w remains unchanged, so we don't need to change spl0
//spl0 = spl0;

// Rotation only affects x and y:
x = spl1;
y = spl2;
// We use SpatDIF (navigational) coordinate system rather than mathematical.
// Hence we need to invert sign of sinRotation as compared to Malham's formula.
spl1 =  x * cosRotationDspCoeff + y * sinRotationDspCoeff;
spl2 = -x * sinRotationDspCoeff + y * cosRotationDspCoeff;

// Tilt only affects y and z:
y = spl2;
z = spl3;
spl2 = y * cosTiltDspCoeff - z * sinTiltDspCoeff;
spl3 = y * sinTiltDspCoeff + z * cosTiltDspCoeff;

// Tumble only affects x and z:
x = spl1;
z = spl3;
spl1 = x * cosTumbleDspCoeff - z * sinTumbleDspCoeff;
spl3 = x * sinTumbleDspCoeff + z * cosTumbleDspCoeff;